<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ğŸŒ¸ ãªã‹ã‚ˆã—ãƒŠãƒ³ãƒãƒ¼ã‚º</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700;800;900&display=swap');

:root {
  --cell: 52px;
  --gap: 4px;
  --radius: 13px;
  --panel-bg: rgba(255,255,255,0.87);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'Nunito', sans-serif;
  min-height: 100vh;
  background: linear-gradient(160deg,#fff0f8 0%,#f0eaff 30%,#e8f5ff 60%,#f0fff4 100%);
  display: flex; flex-direction: column; align-items: center;
  padding: 10px 6px 40px; overflow-x: hidden; position: relative;
}

/* â”€â”€ ANIMALS â”€â”€ */
.animal-stage { position:fixed; inset:0; pointer-events:none; z-index:0; overflow:hidden; }
.sticker { position:absolute; pointer-events:all; cursor:pointer; user-select:none;
  filter:drop-shadow(0 4px 10px rgba(0,0,0,0.11)); }
.sticker svg { display:block; overflow:visible; }
@keyframes sFloat {
  0%,100%{transform:translateY(0) rotate(0deg);}
  30%{transform:translateY(-9px) rotate(2.5deg);}
  70%{transform:translateY(-5px) rotate(-2.5deg);}
}
@keyframes sBounce {
  0%{transform:scale(1);}
  20%{transform:scale(1.35) rotate(-12deg);}
  55%{transform:scale(0.88) rotate(8deg) translateY(-12px);}
  80%{transform:scale(1.08) rotate(-3deg);}
  100%{transform:scale(1) rotate(0);}
}
@keyframes sWiggle {
  0%,100%{transform:rotate(0) scale(1.15);}
  30%{transform:rotate(-8deg) scale(1.18);}
  70%{transform:rotate(8deg) scale(1.18);}
}
.sticker.wiggling{animation:sWiggle 0.38s ease !important;}
.sticker.bouncing{animation:sBounce 0.52s cubic-bezier(.36,.07,.19,.97) !important;}

/* â”€â”€ TITLE â”€â”€ */
.title-wrap{position:relative;z-index:1;text-align:center;margin-bottom:8px;}
h1{
  font-family:'Fredoka One',cursive;
  font-size:clamp(22px,5vw,40px);
  background:linear-gradient(135deg,#ff5fa0,#b05fff,#5fb0ff);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;
  line-height:1.1;
}
.title-sub{font-size:11px;color:#c090d8;font-weight:800;letter-spacing:1px;}

/* â”€â”€ GAME PANEL â”€â”€ */
.game-panel{
  position:relative;z-index:1;
  background:var(--panel-bg);backdrop-filter:blur(14px);
  border-radius:22px;padding:14px 12px 12px;
  box-shadow:0 8px 32px rgba(180,130,220,0.16),0 0 0 2px rgba(255,255,255,0.9);
  width:100%;max-width:700px;
}

/* â”€â”€ STATS â”€â”€ */
.stats-bar{display:flex;align-items:center;gap:6px;margin-bottom:10px;flex-wrap:wrap;justify-content:space-between;}
.pill{
  display:flex;align-items:center;gap:5px;
  background:linear-gradient(135deg,#fff0f8,#f4eeff);
  border-radius:50px;padding:4px 11px;
  box-shadow:0 2px 7px rgba(200,140,220,0.14);
  border:2px solid rgba(255,255,255,0.85);
}
.pill-icon{font-size:14px;}
.pill-texts{display:flex;flex-direction:column;line-height:1.1;}
.pill-label{font-size:8px;font-weight:900;color:#c08ad8;letter-spacing:1px;text-transform:uppercase;}
.pill-val{font-family:'Fredoka One',cursive;font-size:17px;color:#9060cc;}
.pill-val.warn{color:#ee5555;}.pill-val.ok{color:#44bb66;}

.hdr-btn{
  font-family:'Fredoka One',cursive;font-size:13px;
  border-radius:50px;cursor:pointer;padding:5px 13px;
  border:2px solid rgba(255,255,255,0.8);
  transition:transform 0.17s cubic-bezier(.34,1.56,.64,1);
}
.hdr-btn:hover:not(:disabled){transform:scale(1.07) translateY(-1px);}
.hdr-btn:disabled{opacity:0.4;cursor:not-allowed;}
.rules-btn{background:linear-gradient(135deg,#ffe0f2,#e8d4ff);color:#aa66cc;
  box-shadow:0 3px 9px rgba(200,130,220,0.18);}
.reset-btn{background:linear-gradient(135deg,#d4ecff,#c8e8ff);color:#4488cc;
  box-shadow:0 3px 9px rgba(100,160,220,0.18);}
.undo-btn{background:linear-gradient(135deg,#fffde0,#ffebb0);color:#bb8800;
  box-shadow:0 3px 9px rgba(220,180,80,0.18);}
.hint-btn{background:linear-gradient(135deg,#d0ffe8,#a0ffcc);color:#228866;
  box-shadow:0 3px 9px rgba(80,200,140,0.18);}
.hint-btn.active{background:linear-gradient(135deg,#a0ffcc,#60ffaa);
  box-shadow:0 0 0 3px #44cc88,0 3px 9px rgba(80,200,140,0.4);}

/* â”€â”€ RULES â”€â”€ */
.rules-panel{
  background:linear-gradient(135deg,rgba(255,235,248,0.9),rgba(235,225,255,0.9));
  border-radius:14px;padding:10px 14px;margin-bottom:10px;
  font-size:11px;line-height:2;color:#9a77b0;
  border:2px solid rgba(255,255,255,0.7);display:none;
}
.rules-panel.open{display:block;}
.rules-panel b{color:#cc55aa;}

/* â”€â”€ STAGE BANNER â”€â”€ */
.stage-banner{text-align:center;font-family:'Fredoka One',cursive;
  font-size:13px;color:#b070d8;margin-bottom:6px;letter-spacing:1px;}

/* â”€â”€ GRID â”€â”€ */
.grid-scroll{overflow:visible;margin-bottom:10px;}
#gridWrap{display:flex;flex-direction:column;gap:var(--gap);}
.grid-row{display:flex;gap:var(--gap);}
.grid-row.row-vanish{animation:rowPoof 0.5s cubic-bezier(.36,.07,.19,.97) forwards;}
@keyframes rowPoof{
  0%{transform:scaleY(1);opacity:1;filter:brightness(1);}
  35%{transform:scaleY(1.05);opacity:1;filter:brightness(1.8) saturate(2.5);}
  100%{transform:scaleY(0);opacity:0;}
}

/* â”€â”€ CELLS â”€â”€ */
.cell{
  height:var(--cell);
  border-radius:var(--radius);
  display:flex;align-items:center;justify-content:center;
  font-family:'Fredoka One',cursive;font-size:20px;
  cursor:pointer;user-select:none;
  border:2px solid rgba(255,255,255,0.72);
  box-shadow:0 3px 7px rgba(0,0,0,0.09),0 1px 0 rgba(255,255,255,0.88) inset;
  transition:transform 0.12s cubic-bezier(.34,1.56,.64,1),box-shadow 0.12s,filter 0.12s;
  position:relative;overflow:hidden;flex-shrink:0;
}
.cell::after{
  content:'';position:absolute;top:3px;left:10px;right:10px;height:32%;
  background:rgba(255,255,255,0.42);border-radius:50%;pointer-events:none;
}
.cell[data-v="1"]{background:linear-gradient(145deg,#ffc8dd,#ff90b8);color:#c0245e;}
.cell[data-v="2"]{background:linear-gradient(145deg,#ffdcb0,#ffb870);color:#aa4408;}
.cell[data-v="3"]{background:linear-gradient(145deg,#fff4a0,#ffe040);color:#887000;}
.cell[data-v="4"]{background:linear-gradient(145deg,#b8f5b8,#70e870);color:#1a7a1a;}
.cell[data-v="5"]{background:linear-gradient(145deg,#a8f0e4,#50dcc4);color:#107860;}
.cell[data-v="6"]{background:linear-gradient(145deg,#aadefc,#60c0ff);color:#1058b0;}
.cell[data-v="7"]{background:linear-gradient(145deg,#ccc0ff,#9980ff);color:#3818b8;}
.cell[data-v="8"]{background:linear-gradient(145deg,#f8b8f0,#f070e0);color:#a01090;}
.cell[data-v="9"]{background:linear-gradient(145deg,#ffc8b0,#ff9870);color:#b02808;}

.cell:hover:not(.dead):not(.sel):not(.sel-chain):not(.popping){
  transform:translateY(-4px) scale(1.1);
  box-shadow:0 8px 18px rgba(0,0,0,0.13);filter:brightness(1.06);z-index:2;
}
/* first selected cell */
.cell.sel{
  transform:translateY(-5px) scale(1.12);
  box-shadow:0 0 0 3.5px #ff66bb,0 8px 22px rgba(255,80,180,0.4);z-index:3;
  animation:selPulse 0.55s ease infinite alternate;
}
/* additional cells in chain */
.cell.sel-chain{
  transform:translateY(-4px) scale(1.08);
  box-shadow:0 0 0 3px #ff99dd,0 6px 16px rgba(255,80,180,0.35);z-index:3;
  animation:selPulse 0.55s ease 0.15s infinite alternate;
}
@keyframes selPulse{
  from{box-shadow:0 0 0 3px #ff66bb,0 6px 18px rgba(255,80,180,0.3);}
  to{box-shadow:0 0 0 5px #ffaadd,0 10px 28px rgba(255,80,180,0.5);}
}
/* hint highlight */
.cell.hint{
  animation:hintPulse 0.7s ease infinite alternate;z-index:4;
}
@keyframes hintPulse{
  from{box-shadow:0 0 0 3px #44cc88,0 0 12px rgba(68,204,136,0.4);filter:brightness(1.1);}
  to{box-shadow:0 0 0 6px #88ffcc,0 0 24px rgba(68,204,136,0.7);filter:brightness(1.25);}
}
.cell.hint-dim{opacity:0.55;filter:saturate(0.4);}

.cell.popping{animation:cellPop 0.42s cubic-bezier(.36,.07,.19,.97) forwards;}
@keyframes cellPop{
  0%{transform:scale(1);opacity:1;}
  35%{transform:scale(1.4) rotate(12deg);opacity:1;filter:brightness(1.8);}
  100%{transform:scale(0) rotate(-15deg);opacity:0;}
}
.cell.dead{
  background:linear-gradient(145deg,#eeecf2,#e6e2ea) !important;
  color:transparent !important;border-color:rgba(210,200,215,0.25) !important;
  box-shadow:none !important;cursor:default;opacity:0.38;
}
.cell.dead::after{display:none;}
.cell.new-appear{animation:newBounce 0.36s cubic-bezier(.34,1.56,.64,1) both;}
@keyframes newBounce{
  0%{transform:scale(0) translateY(-14px);opacity:0;}
  65%{transform:scale(1.1) translateY(0);opacity:1;}
  100%{transform:scale(1);opacity:1;}
}

/* â”€â”€ SELECTION TOTAL BADGE â”€â”€ */
.sel-total{
  position:fixed;z-index:500;pointer-events:none;
  font-family:'Fredoka One',cursive;font-size:18px;
  background:linear-gradient(135deg,#ff66bb,#cc44ff);
  color:white;border-radius:50px;padding:4px 14px;
  box-shadow:0 4px 14px rgba(200,80,200,0.4);
  transform:translate(-50%,-50%);
  animation:badgePop 0.2s cubic-bezier(.34,1.56,.64,1);
  white-space:nowrap;
}
@keyframes badgePop{from{transform:translate(-50%,-50%) scale(0.5);}to{transform:translate(-50%,-50%) scale(1);}}

/* â”€â”€ BOTTOM BAR â”€â”€ */
.bottom-bar{display:flex;align-items:center;gap:6px;flex-wrap:wrap;justify-content:space-between;}
.add-btn{
  font-family:'Fredoka One',cursive;font-size:14px;
  padding:9px 16px;border-radius:50px;cursor:pointer;
  background:linear-gradient(135deg,#ffb0d8,#d090ff);color:white;
  border:2.5px solid rgba(255,255,255,0.72);
  box-shadow:0 4px 13px rgba(220,120,200,0.36);
  transition:transform 0.17s cubic-bezier(.34,1.56,.64,1),box-shadow 0.17s,opacity 0.2s;
  text-shadow:0 1px 3px rgba(160,50,140,0.32);
}
.add-btn:hover:not(:disabled){transform:scale(1.07) translateY(-2px);box-shadow:0 7px 18px rgba(220,120,200,0.5);}
.add-btn:active{transform:scale(0.95);}
.add-btn:disabled{opacity:0.4;cursor:not-allowed;}

.msg{flex:1;text-align:center;font-size:12px;font-weight:800;color:#c08ad8;
  min-height:18px;transition:color 0.2s;}
.msg.err{color:#ff5577;}.msg.ok{color:#44bb77;}.msg.wow{color:#ff8800;}.msg.bonus{color:#9933ff;}

/* â”€â”€ FLOAT TEXT â”€â”€ */
.float-text{
  position:fixed;pointer-events:none;z-index:500;
  font-family:'Fredoka One',cursive;font-size:22px;
  white-space:nowrap;user-select:none;
  animation:floatUp 0.95s ease forwards;
}
@keyframes floatUp{
  0%{opacity:1;transform:translateY(0) scale(1);}
  70%{opacity:1;transform:translateY(-55px) scale(1.1);}
  100%{opacity:0;transform:translateY(-80px) scale(0.8);}
}

/* â”€â”€ CONFETTI â”€â”€ */
.conf{position:fixed;pointer-events:none;z-index:600;font-size:18px;animation:confFly 0.9s ease forwards;}
@keyframes confFly{
  0%{opacity:1;transform:translate(0,0) scale(1) rotate(0);}
  100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0.2) rotate(var(--rot));}
}

/* â”€â”€ OVERLAY â”€â”€ */
.overlay{
  display:none;position:fixed;inset:0;
  background:rgba(255,230,248,0.65);backdrop-filter:blur(8px);
  z-index:800;align-items:center;justify-content:center;
}
.overlay.show{display:flex;}
.ov-box{
  background:white;border-radius:26px;padding:34px 46px;text-align:center;
  box-shadow:0 16px 55px rgba(200,100,200,0.25);
  border:3px solid rgba(255,200,235,0.5);max-width:340px;width:90%;
}
.ov-emoji{font-size:46px;margin-bottom:8px;}
.ov-title{
  font-family:'Fredoka One',cursive;font-size:38px;
  background:linear-gradient(135deg,#ff5fa0,#a060ff);
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;
  margin-bottom:5px;
}
.ov-sub{color:#c090d8;font-size:12px;font-weight:800;margin-bottom:18px;line-height:1.8;}
.ov-btn{
  font-family:'Fredoka One',cursive;font-size:17px;
  padding:11px 30px;border-radius:50px;cursor:pointer;
  background:linear-gradient(135deg,#ffb0d8,#d090ff);
  color:white;border:3px solid rgba(255,255,255,0.8);
  box-shadow:0 5px 15px rgba(220,120,200,0.38);
  transition:transform 0.17s cubic-bezier(.34,1.56,.64,1);
}
.ov-btn:hover{transform:scale(1.07);}

.stage-flash{position:fixed;inset:0;z-index:750;pointer-events:none;
  background:white;opacity:0;animation:flashIn 0.6s ease forwards;}
@keyframes flashIn{0%{opacity:0;}30%{opacity:0.7;}100%{opacity:0;}}
</style>
</head>
<body>

<div class="animal-stage" id="animalStage"></div>

<div class="title-wrap">
  <h1>ğŸŒ¸ ãªã‹ã‚ˆã—ãƒŠãƒ³ãƒãƒ¼ã‚º</h1>
  <p class="title-sub">ã¿ã‚“ãªã§ãªã‹ã‚ˆã ããˆã¡ã‚ƒãŠã†â™ª</p>
</div>

<div class="game-panel">
  <div class="stats-bar">
    <div class="pill">
      <span class="pill-icon">â­</span>
      <div class="pill-texts"><span class="pill-label">SCORE</span><span class="pill-val" id="scoreVal">0</span></div>
    </div>
    <div class="pill">
      <span class="pill-icon">ğŸ’•</span>
      <div class="pill-texts"><span class="pill-label">PAIRS</span><span class="pill-val" id="pairsVal">0</span></div>
    </div>
    <div class="pill">
      <span class="pill-icon">â•</span>
      <div class="pill-texts"><span class="pill-label">ADD</span><span class="pill-val" id="addVal">6</span></div>
    </div>
    <button class="hdr-btn hint-btn" id="hintBtn" onclick="toggleHint()">ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
    <button class="hdr-btn undo-btn" id="undoBtn" onclick="undoMove()" disabled>â†© ã‚‚ã©ã‚‹</button>
  </div>
  <div class="stats-bar" style="margin-bottom:8px;">
    <button class="hdr-btn rules-btn" onclick="toggleRules()">ğŸŒ¸ ãƒ«ãƒ¼ãƒ«</button>
    <button class="hdr-btn reset-btn" onclick="resetGame()">â†º ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <div class="rules-panel" id="rulesPanel">
    ğŸ£ ç¸¦ãƒ»æ¨ªãƒ»æ–œã‚ã«<b>éš£æ¥ã™ã‚‹æ•°å­—</b>ã‚’é †ç•ªã«ã‚¯ãƒªãƒƒã‚¯ï¼<br>
    ğŸ’• <b>åŒã˜æ•°å­—2å€‹</b>ã¾ãŸã¯<b>åˆè¨ˆãŒ10ã«ãªã‚‹é€£ç¶šåˆ—</b>ãŒæ¶ˆãˆã‚‹ã‚ˆâœ¨<br>
    ğŸ”¢ ä¾‹ï¼š<b>3â†’4â†’3</b>ï¼ˆåˆè¨ˆ10ï¼‰ã€<b>2â†’3â†’5</b>ï¼ˆåˆè¨ˆ10ï¼‰ã€<b>5â†’5</b>ï¼ˆåŒã˜ï¼‰<br>
    ğŸ¾ æ¶ˆãˆãŸç©´ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¦éš£æ¥åˆ¤å®šï¼ˆ<b>1â–«â–«1</b>â†’ä¸¡ç«¯ã¯éš£æ¥ï¼‰<br>
    ğŸ¦† <b>è¡Œã®å³ç«¯</b>ã¯<b>æ¬¡ã®è¡Œã®å·¦ç«¯</b>ã«éš£æ¥ã—ã¦ã‚‹ã‚ˆï¼<br>
    ğŸ“ <b>é›¢ã‚ŒãŸãƒšã‚¢</b>ã»ã©ãƒœãƒ¼ãƒŠã‚¹ç‚¹ãŒå¤§ãã„ã‚ˆï¼<br>
    ğŸ’¡ <b>ãƒ’ãƒ³ãƒˆ</b>ã§æ¬¡ã«æ¶ˆã›ã‚‹å ´æ‰€ã‚’æ•™ãˆã¦ã‚‚ã‚‰ãˆã‚‹ã‚ˆï¼<br>
    â†© <b>ã‚‚ã©ã‚‹</b>ã§1æ‰‹æˆ»ã‚Œã‚‹ã‚ˆï¼<br>
    ğŸ† å…¨éƒ¨æ¶ˆã—ãŸã‚‰<b>ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢</b>ï¼
  </div>

  <div class="stage-banner" id="stageBanner">ã‚¹ãƒ†ãƒ¼ã‚¸ 1</div>

  <div class="grid-scroll">
    <div id="gridWrap"></div>
  </div>

  <div class="bottom-bar">
    <button class="add-btn" id="addBtn" onclick="addRows()">ï¼‹ è¡Œè¿½åŠ </button>
    <span class="msg" id="msg">ã™ããªæ•°å­—ã‚’ãˆã‚‰ã‚“ã§ã­ï¼</span>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="ov-box">
    <div class="ov-emoji" id="ovEmoji">ğŸ‰</div>
    <div class="ov-title" id="ovTitle">ã™ã”ã„ï¼</div>
    <div class="ov-sub"   id="ovSub">ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼</div>
    <button class="ov-btn" id="ovBtn" onclick="overlayAction()">ã¤ãã¸ï¼</button>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMAL SVGs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SVGS = {
  chick:(s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="40" cy="52" rx="22" ry="20" fill="#FFE066" stroke="#E8A800" stroke-width="2"/>
    <circle cx="40" cy="28" r="18" fill="#FFE566" stroke="#E8A800" stroke-width="2"/>
    <ellipse cx="20" cy="54" rx="9" ry="6" fill="#FFD022" stroke="#E8A800" stroke-width="1.5" transform="rotate(-20 20 54)"/>
    <ellipse cx="60" cy="54" rx="9" ry="6" fill="#FFD022" stroke="#E8A800" stroke-width="1.5" transform="rotate(20 60 54)"/>
    <ellipse cx="40" cy="33" rx="5" ry="3.5" fill="#FF9922" stroke="#DD7700" stroke-width="1.5"/>
    <circle cx="33" cy="24" r="4" fill="white"/><circle cx="33" cy="24" r="2.5" fill="#222"/><circle cx="34" cy="23" r="1" fill="white"/>
    <circle cx="47" cy="24" r="4" fill="white"/><circle cx="47" cy="24" r="2.5" fill="#222"/><circle cx="48" cy="23" r="1" fill="white"/>
    <ellipse cx="28" cy="30" rx="4" ry="2.5" fill="#FFB0B0" opacity="0.7"/>
    <ellipse cx="52" cy="30" rx="4" ry="2.5" fill="#FFB0B0" opacity="0.7"/>
    <line x1="34" y1="70" x2="30" y2="76" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="34" y1="70" x2="34" y2="77" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="46" y1="70" x2="42" y2="76" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="46" y1="70" x2="46" y2="77" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
  </svg>`,
  dog:(s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="20" cy="22" rx="10" ry="14" fill="#D4956A" stroke="#A06030" stroke-width="1.5" transform="rotate(-15 20 22)"/>
    <ellipse cx="60" cy="22" rx="10" ry="14" fill="#D4956A" stroke="#A06030" stroke-width="1.5" transform="rotate(15 60 22)"/>
    <circle cx="40" cy="32" r="22" fill="#E8B080" stroke="#A06030" stroke-width="2"/>
    <ellipse cx="40" cy="62" rx="18" ry="14" fill="#E8B080" stroke="#A06030" stroke-width="2"/>
    <ellipse cx="40" cy="40" rx="12" ry="9" fill="#F5CFA0"/>
    <ellipse cx="40" cy="35" rx="5" ry="3.5" fill="#442200"/>
    <ellipse cx="41" cy="34" rx="1.5" ry="1" fill="white" opacity="0.5"/>
    <path d="M34 42 Q40 47 46 42" stroke="#A06030" stroke-width="1.8" fill="none" stroke-linecap="round"/>
    <circle cx="31" cy="27" r="4.5" fill="white"/><circle cx="31" cy="27" r="3" fill="#3a1800"/><circle cx="32.5" cy="25.5" r="1.2" fill="white"/>
    <circle cx="49" cy="27" r="4.5" fill="white"/><circle cx="49" cy="27" r="3" fill="#3a1800"/><circle cx="50.5" cy="25.5" r="1.2" fill="white"/>
    <ellipse cx="24" cy="36" rx="5" ry="3" fill="#FFB0A0" opacity="0.6"/>
    <ellipse cx="56" cy="36" rx="5" ry="3" fill="#FFB0A0" opacity="0.6"/>
    <path d="M56 62 Q70 50 66 42" stroke="#E8B080" stroke-width="6" fill="none" stroke-linecap="round"/>
    <path d="M56 62 Q70 50 66 42" stroke="#A06030" stroke-width="2" fill="none" stroke-linecap="round"/>
  </svg>`,
  cat:(s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <polygon points="14,28 22,8 30,28" fill="#FFAACC" stroke="#D06080" stroke-width="1.5" stroke-linejoin="round"/>
    <polygon points="18,26 22,13 28,26" fill="#FFD4E8"/>
    <polygon points="50,28 58,8 66,28" fill="#FFAACC" stroke="#D06080" stroke-width="1.5" stroke-linejoin="round"/>
    <polygon points="52,26 58,13 64,26" fill="#FFD4E8"/>
    <circle cx="40" cy="36" r="22" fill="#FFBBDD" stroke="#D06080" stroke-width="2"/>
    <ellipse cx="40" cy="64" rx="17" ry="13" fill="#FFBBDD" stroke="#D06080" stroke-width="2"/>
    <line x1="14" y1="38" x2="30" y2="40" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <line x1="14" y1="42" x2="30" y2="42" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <line x1="50" y1="40" x2="66" y2="38" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <line x1="50" y1="42" x2="66" y2="42" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <ellipse cx="40" cy="43" rx="10" ry="7" fill="#FFD8EC"/>
    <path d="M38 39 L42 39 L40 41 Z" fill="#FF6699"/>
    <path d="M37 42 Q40 46 43 42" stroke="#D06080" stroke-width="1.5" fill="none" stroke-linecap="round"/>
    <ellipse cx="31" cy="32" rx="4.5" ry="5" fill="white"/><ellipse cx="31" cy="32" rx="2.5" ry="4" fill="#2a0a1a"/><circle cx="32" cy="30" r="1.2" fill="white"/>
    <ellipse cx="49" cy="32" rx="4.5" ry="5" fill="white"/><ellipse cx="49" cy="32" rx="2.5" ry="4" fill="#2a0a1a"/><circle cx="50" cy="30" r="1.2" fill="white"/>
    <ellipse cx="24" cy="40" rx="5" ry="3" fill="#FFB0C8" opacity="0.55"/>
    <ellipse cx="56" cy="40" rx="5" ry="3" fill="#FFB0C8" opacity="0.55"/>
    <path d="M55 70 Q72 68 70 55 Q68 44 62 46" stroke="#FFBBDD" stroke-width="6" fill="none" stroke-linecap="round"/>
    <path d="M55 70 Q72 68 70 55 Q68 44 62 46" stroke="#D06080" stroke-width="2" fill="none" stroke-linecap="round"/>
  </svg>`,
  duck:(s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="42" cy="56" rx="24" ry="18" fill="#AADDFF" stroke="#5599CC" stroke-width="2"/>
    <ellipse cx="52" cy="54" rx="14" ry="9" fill="#88CCFF" stroke="#5599CC" stroke-width="1.5" transform="rotate(15 52 54)"/>
    <circle cx="28" cy="30" r="17" fill="#AADDFF" stroke="#5599CC" stroke-width="2"/>
    <path d="M14 29 Q8 30 8 34 Q8 37 14 37 L20 33 Z" fill="#FFCC44" stroke="#CC8800" stroke-width="1.5" stroke-linejoin="round"/>
    <ellipse cx="13" cy="36" rx="6" ry="2.5" fill="#FFAA22" stroke="#CC8800" stroke-width="1"/>
    <circle cx="24" cy="24" r="4.5" fill="white"/><circle cx="24" cy="24" r="3" fill="#1a1a2a"/><circle cx="25.5" cy="22.5" r="1.2" fill="white"/>
    <path d="M28 14 Q32 4 36 12" stroke="#88CCFF" stroke-width="3" fill="none" stroke-linecap="round"/>
    <ellipse cx="20" cy="32" rx="4" ry="2.5" fill="#FFB0D0" opacity="0.6"/>
    <path d="M32 72 Q28 76 24 76 M32 72 Q31 76 27 78 M32 72 L32 78" stroke="#FFCC44" stroke-width="2.5" fill="none" stroke-linecap="round"/>
    <path d="M50 72 Q46 76 42 76 M50 72 Q49 76 45 78 M50 72 L50 78" stroke="#FFCC44" stroke-width="2.5" fill="none" stroke-linecap="round"/>
    <path d="M34 42 Q36 50 42 54" stroke="#AADDFF" stroke-width="8" fill="none" stroke-linecap="round"/>
    <path d="M34 42 Q36 50 42 54" stroke="#5599CC" stroke-width="2" fill="none" stroke-linecap="round"/>
  </svg>`
};

const CONF_CHARS=['âœ¨','ğŸ’«','ğŸŒ¸','â­','ğŸ’•','ğŸ€','ğŸŒŸ','ğŸ’–','ğŸ¬','ğŸŠ','ğŸŒˆ','ğŸ¦‹'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GLOBAL STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let COLS = 8;
const CELL_MIN_PX = 38, CELL_MAX_PX = 56, GAP_PX = 4, PANEL_PAD = 24;

let grid      = [];       // grid[r][c]: number|null
let chain     = [];       // [{r,c}] currently selected chain
let chainDir  = null;     // {dr,dc} direction locked after 2nd cell
let score     = 0;
let pairs     = 0;
let stage     = 1;
let addsLeft  = 0;
let busy      = false;
let overlayMode = 'clear';

let undoStack = [];       // stack of {grid, score, pairs, addsLeft} snapshots
let hintActive = false;
let hintMove   = null;    // [{r,c},...] the move to highlight

// badge DOM element
let badgeEl = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STAGE CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function stageCfg(s){
  return {
    rows:    Math.min(3+Math.floor((s-1)/2), 6),
    adds:    Math.max(7-s, 2),
    pairRate:Math.max(0.45-(s-1)*0.04, 0.18),
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LAYOUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcCols(){
  const panelW = Math.min(window.innerWidth-12, 700);
  const inner  = panelW - PANEL_PAD*2;
  for(let c=10;c>=6;c--){
    const cw=(inner-GAP_PX*(c-1))/c;
    if(cw>=CELL_MIN_PX) return {cols:c, cellW:Math.min(cw,CELL_MAX_PX)};
  }
  return {cols:6, cellW:(inner-GAP_PX*5)/6};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GRID WALK (shared, uses current COLS/grid)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DIRS8=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

function walkAlive(g, r, c, dr, dc){
  const maxSteps=g.length*COLS+4;
  let cr=r, cc=c;
  for(let i=0;i<maxSteps;i++){
    if(dr===0){
      cc+=dc;
      if(cc<0){cc=COLS-1;cr--;}
      else if(cc>=COLS){cc=0;cr++;}
    } else {
      cr+=dr; cc+=dc;
      if(cc<0||cc>=COLS) return null;
    }
    if(cr<0||cr>=g.length) return null;
    if(cr===r&&cc===c) return null;
    if(g[cr][cc]!==null) return {r:cr,c:cc};
  }
  return null;
}

// One step (raw, no skip) in direction, returning {r,c} or null
function oneStep(r,c,dr,dc){
  let nr=r, nc=c;
  if(dr===0){
    nc+=dc;
    if(nc<0){nc=COLS-1;nr--;}
    else if(nc>=COLS){nc=0;nr++;}
  } else {
    nr+=dr; nc+=dc;
    if(nc<0||nc>=COLS) return null;
  }
  if(nr<0||nr>=grid.length) return null;
  return {r:nr,c:nc};
}

// Direction from (r1,c1) to (r2,c2) - only valid if they are 1 raw step apart
function dirBetween(r1,c1,r2,c2){
  for(const [dr,dc] of DIRS8){
    const s=oneStep(r1,c1,dr,dc);
    if(s&&s.r===r2&&s.c===c2) return {dr,dc};
  }
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHAIN VALIDITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// A valid move is a chain of 2+ ADJACENT (no skip) cells in a FIXED direction where:
//   - all cells are alive
//   - either: exactly 2 cells with same value, OR sum of all values === 10
function chainSum(ch){ return ch.reduce((s,p)=>s+(grid[p.r]?.[p.c]??0),0); }

function chainIsValid(ch){
  if(ch.length<2) return false;
  const vals=ch.map(p=>grid[p.r][p.c]);
  if(vals.some(v=>typeof v!=='number'||v<1||v>9)) return false;
  const sum=vals.reduce((a,b)=>a+b,0);
  if(ch.length===2&&vals[0]===vals[1]) return true; // same pair
  return sum===10;
}

// Can the chain still potentially become valid by extending?
function chainCouldExtend(ch){
  if(ch.length===0) return true;
  const vals=ch.map(p=>grid[p.r][p.c]);
  const sum=vals.reduce((a,b)=>a+b,0);
  if(sum>10) return false; // overshot
  if(ch.length===2&&vals[0]===vals[1]) return false; // already a valid same-pair, don't extend
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ENUMERATE ALL VALID MOVES on a grid g
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function allMovesOnGrid(g){
  const moves=[];
  const R=g.length;
  // For each starting cell and each of 8 directions,
  // extend as far as possible collecting cells (raw steps, same direction)
  // and record sub-chains that are valid.
  for(let r=0;r<R;r++){
    for(let c=0;c<COLS;c++){
      if(g[r][c]===null) continue;
      for(const [dr,dc] of DIRS8){
        // Only extend in 4 "forward" directions to avoid duplicates
        // (we'll capture reverse via the other 4 directions)
        // Actually enumerate all 8 but deduplicate at the end via canonical key
        const chain=[{r,c}];
        let cr=r,cc=c;
        // keep extending
        for(let step=0;step<15;step++){
          // raw one step in direction
          let nr=cr,nc=cc;
          if(dr===0){
            nc+=dc;
            if(nc<0){nc=COLS-1;nr--;}
            else if(nc>=COLS){nc=0;nr++;}
          } else {
            nr+=dr;nc+=dc;
            if(nc<0||nc>=COLS) break;
          }
          if(nr<0||nr>=R) break;
          if(g[nr][nc]===null){cr=nr;cc=nc;continue;} // skip dead
          chain.push({r:nr,c:nc});
          cr=nr;cc=nc;

          // check if current chain is valid
          const vals=chain.map(p=>g[p.r][p.c]);
          const sum=vals.reduce((a,b)=>a+b,0);
          if(sum>10) break; // can't get better
          const same=chain.length===2&&vals[0]===vals[1];
          if(same||(sum===10&&chain.length>=2)){
            // record a canonical key to dedup
            moves.push([...chain]);
            if(sum===10) break; // no point extending further
          }
        }
      }
    }
  }
  // Deduplicate by sorted cell keys
  const seen=new Set();
  return moves.filter(m=>{
    const key=m.map(p=>p.r*100+p.c).sort((a,b)=>a-b).join(',');
    if(seen.has(key)) return false;
    seen.add(key); return true;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  APPLY MOVE on grid g, return new grid
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function applyMove(g, move){
  const ng=g.map(r=>[...r]);
  move.forEach(({r,c})=>ng[r][c]=null);
  return ng;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HINT SYSTEM
//  Find a sequence of moves that clears the board.
//  Uses iterative deepening greedy with backtrack.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findHintMove(){
  // First try greedy (fast): prefer moves that clear rows or have high value
  const g=grid.map(r=>[...r]);
  const seq=solveGreedy(g, 40);
  if(seq&&seq.length>0) return seq[0];
  // Fallback: just return any valid move
  const moves=allMovesOnGrid(g);
  if(moves.length>0){
    // prefer moves clearing a whole row
    for(const m of moves){
      const ng=applyMove(g,m);
      if(ng.some(row=>row.every(v=>v===null))) return m;
    }
    return moves[0];
  }
  return null;
}

// Greedy solver: always picks the move that leaves most pairs / clears most cells
function solveGreedy(g, maxMoves){
  const seq=[];
  let cur=g.map(r=>[...r]);
  for(let i=0;i<maxMoves;i++){
    if(isEmpty(cur)) return seq;
    const moves=allMovesOnGrid(cur);
    if(moves.length===0) return null;
    // score each move
    let best=null, bestScore=-Infinity;
    for(const m of moves){
      const ng=applyMove(cur,m);
      const s=moveScore(ng,m);
      if(s>bestScore){bestScore=s;best=m;}
    }
    seq.push(best);
    cur=applyMove(cur,best);
  }
  return isEmpty(cur)?seq:null;
}

function moveScore(ng, move){
  let s=move.length*5;
  // bonus for clearing a whole row
  ng.forEach(row=>{ if(row.every(v=>v===null)) s+=30; });
  // bonus for number of subsequent moves available
  s+=allMovesOnGrid(ng).length;
  return s;
}

function isEmpty(g){ return g.every(row=>row.every(v=>v===null)); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render(newRowIdxs=[]){
  const wrap=document.getElementById('gridWrap');
  wrap.innerHTML='';

  const {cellW}=calcCols();
  const cw=Math.floor(cellW);
  const fs=Math.floor(cellW*0.38);
  const rr=Math.min(Math.floor(cellW*0.26),16);
  document.documentElement.style.setProperty('--cell',cw+'px');
  document.documentElement.style.setProperty('--radius',rr+'px');

  // Build sets for fast lookup
  const chainSet=new Set(chain.map(p=>p.r+','+p.c));
  const hintSet=hintMove?new Set(hintMove.map(p=>p.r+','+p.c)):null;

  for(let r=0;r<grid.length;r++){
    const rowEl=document.createElement('div');
    rowEl.className='grid-row'; rowEl.dataset.row=r;
    for(let c=0;c<COLS;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      cell.style.width=cw+'px'; cell.style.fontSize=fs+'px';
      const v=grid[r][c];
      const vOk=(typeof v==='number'&&Number.isInteger(v)&&v>=1&&v<=9);

      if(!vOk){
        if(v!==null) grid[r][c]=null;
        cell.classList.add('dead');
      } else {
        cell.dataset.v=v; cell.dataset.r=r; cell.dataset.c=c;
        cell.textContent=v;
        cell.addEventListener('click',()=>onCell(r,c));

        const key=r+','+c;
        if(chainSet.has(key)){
          cell.classList.add(chain[0].r===r&&chain[0].c===c?'sel':'sel-chain');
        } else if(hintSet&&hintSet.has(key)){
          cell.classList.add('hint');
        } else if(hintSet&&!hintSet.has(key)&&hintActive){
          cell.classList.add('hint-dim');
        }
      }
      if(newRowIdxs.includes(r)){
        cell.classList.add('new-appear');
        cell.style.animationDelay=(c*26)+'ms';
      }
      rowEl.appendChild(cell);
    }
    wrap.appendChild(rowEl);
  }
  updateStats();
  updateBadge();
}

function getCell(r,c){ return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHAIN BADGE  (shows current sum)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateBadge(){
  if(badgeEl){ badgeEl.remove(); badgeEl=null; }
  if(chain.length<1) return;
  const last=chain[chain.length-1];
  const cellEl=getCell(last.r,last.c);
  if(!cellEl) return;
  const rect=cellEl.getBoundingClientRect();
  const sum=chainSum(chain);
  const vals=chain.map(p=>grid[p.r][p.c]);
  const isSame=chain.length===2&&vals[0]===vals[1];
  const label=isSame?`${vals[0]}=${vals[0]}`:`åˆè¨ˆ${sum}`;
  badgeEl=document.createElement('div');
  badgeEl.className='sel-total';
  badgeEl.textContent=label;
  badgeEl.style.left=(rect.left+rect.width/2)+'px';
  badgeEl.style.top=(rect.top-18)+'px';
  document.body.appendChild(badgeEl);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CELL CLICK  â€” multi-cell chain selection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onCell(r,c){
  if(busy) return;
  if(grid[r][c]===null) return;

  // clicking already-selected cell: cancel
  if(chain.some(p=>p.r===r&&p.c===c)){
    chain=[]; chainDir=null;
    clearHint();
    render(); setMsg('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã‚ˆã€œ','');
    return;
  }

  if(chain.length===0){
    // Start new chain
    chain=[{r,c}]; chainDir=null;
    render(); setMsg(`${grid[r][c]} ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆï¼ç¶šã‘ã¦ãˆã‚‰ã‚“ã§ã­`,'');
    return;
  }

  // Determine direction from last cell to this one (raw 1 step only)
  const last=chain[chain.length-1];
  const dir=dirBetween(last.r,last.c,r,c);
  if(!dir){
    // Not a direct neighbour â€” start fresh
    chain=[{r,c}]; chainDir=null;
    render(); setMsg(`${grid[r][c]} ã‹ã‚‰æ–°ã—ãã‚¹ã‚¿ãƒ¼ãƒˆï¼`,'');
    return;
  }

  // If chain has 2+ cells, enforce fixed direction
  if(chainDir&&(dir.dr!==chainDir.dr||dir.dc!==chainDir.dc)){
    chain=[{r,c}]; chainDir=null;
    render(); setMsg('æ–¹å‘ãŒå¤‰ã‚ã‚‹ã‹ã‚‰æ–°ã—ãã‚¹ã‚¿ãƒ¼ãƒˆï¼','');
    return;
  }

  // Add to chain
  chain.push({r,c});
  if(chain.length===2) chainDir=dir;

  const vals=chain.map(p=>grid[p.r][p.c]);
  const sum=vals.reduce((a,b)=>a+b,0);
  const isSame=chain.length===2&&vals[0]===vals[1];

  if(sum>10&&!isSame){
    chain=[{r,c}]; chainDir=null;
    render(); setMsg('åˆè¨ˆãŒ10ã‚’è¶…ãˆãŸï¼ã‚‚ã†ä¸€åº¦ãˆã‚‰ã‚“ã§ã­','err');
    return;
  }

  // Check if valid right now
  if(chainIsValid(chain)){
    // Fire!
    commitChain();
    return;
  }

  render();
  if(sum<10) setMsg(`åˆè¨ˆ ${sum}â€¦ ã‚ã¨${10-sum}ã§OKï¼ã‚ã‚‹ã„ã¯åŒã˜æ•°å­—ã‚‚é¸ã¹ã‚‹ã‚ˆ`,'');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COMMIT CHAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function commitChain(){
  const move=[...chain];
  chain=[]; chainDir=null;
  clearHint();

  // Snapshot for undo
  pushUndo();

  busy=true;
  const vals=move.map(p=>grid[p.r][p.c]);

  // Animate
  move.forEach(({r,c})=>{
    const el=getCell(r,c);
    if(el){ el.classList.remove('sel','sel-chain'); el.classList.add('popping'); }
    spawnConf(getCell(r,c));
  });

  // Distance bonus: between first and last cell
  const db=distBonus(move[0].r,move[0].c,move[move.length-1].r,move[move.length-1].c);
  const lengthBonus=(move.length-2)*8; // extra cells beyond 2
  const pts=10+db+lengthBonus;

  setTimeout(()=>{
    move.forEach(({r,c})=>grid[r][c]=null);
    pairs++; score+=pts;
    updateStats();
    render();

    if(db>0||lengthBonus>0){
      const el=getCell(move[move.length-1].r,move[move.length-1].c)||document.querySelector('.game-panel');
      const rect=el.getBoundingClientRect();
      spawnFloatText(`ğŸŒŸï¼‹${pts}ï¼`,rect.left+rect.width/2,rect.top,'#9933ff');
      setMsg(`ãƒœãƒ¼ãƒŠã‚¹ï¼ ï¼‹${pts}ç‚¹ğŸ’«`,'bonus');
    } else {
      const ok=['ããˆãŸï¼ğŸ’•','ã‚„ã£ãŸï¼âœ¨','ã±ã¡ã±ã¡ğŸ‰','ã„ã„ã­ï¼ğŸŒ¸','ãƒŠã‚¤ã‚¹ï¼ğŸ’«'];
      setMsg(ok[Math.floor(Math.random()*ok.length)]+` ï¼‹${pts}ç‚¹ï¼`,'ok');
    }
    checkRowClear(()=>{ busy=false; checkWin(); });
  },400);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DISTANCE BONUS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function distBonus(r1,c1,r2,c2){
  const d=Math.abs((r1*COLS+c1)-(r2*COLS+c2));
  if(d<=1)  return 0;
  if(d<=3)  return 5;
  if(d<=8)  return 15;
  if(d<=15) return 30;
  return 50;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROW CLEAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkRowClear(cb){
  const clearIdxs=[];
  for(let r=0;r<grid.length;r++){
    if(grid[r].every(v=>v===null)) clearIdxs.push(r);
  }
  if(clearIdxs.length===0){ cb(); return; }

  clearIdxs.forEach(r=>{
    const el=document.querySelector(`.grid-row[data-row="${r}"]`);
    if(el) el.classList.add('row-vanish');
  });

  const bonus=clearIdxs.length*60;
  score+=bonus; updateStats();

  clearIdxs.forEach(r=>{
    const el=document.querySelector(`.grid-row[data-row="${r}"]`);
    if(el){
      const rect=el.getBoundingClientRect();
      spawnFloatText(`ğŸŒˆ${clearIdxs.length}è¡Œæ¶ˆæ»…ï¼ï¼‹${bonus}ï¼`,
        rect.left+rect.width/2,rect.top+rect.height/2,'#ff8800');
    }
  });
  bigConfetti(10);

  setTimeout(()=>{
    for(let i=clearIdxs.length-1;i>=0;i--) grid.splice(clearIdxs[i],1);
    if(grid.length===0) grid=[];
    render();
    setMsg(`ğŸŒˆè¡Œã¾ã‚‹ã”ã¨æ¶ˆãˆãŸï¼ï¼‹${bonus}ç‚¹ãƒœãƒ¼ãƒŠã‚¹ï¼`,'wow');
    cb();
  },560);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ADD ROWS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addRows(){
  if(busy||addsLeft<=0) return;
  addsLeft--;
  pushUndo();
  updateStats();

  const count=1+Math.floor(Math.random()*2);
  const newRows=buildAddRows(count);
  const startIdx=grid.length;
  newRows.forEach(r=>grid.push(r));

  clearHint();
  render(Array.from({length:count},(_,i)=>startIdx+i));
  setMsg(['ğŸ£','ğŸ¶','ğŸ±','ğŸ¦†'][Math.floor(Math.random()*4)]+` ${count}è¡Œã‚ãŸã‚‰ã—ã„ä»²é–“ï¼`,'ok');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UNDO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function pushUndo(){
  undoStack.push({
    grid:grid.map(r=>[...r]),
    score,pairs,addsLeft
  });
  if(undoStack.length>20) undoStack.shift();
  document.getElementById('undoBtn').disabled=false;
}

function undoMove(){
  if(undoStack.length===0) return;
  const snap=undoStack.pop();
  grid=snap.grid;
  score=snap.score; pairs=snap.pairs; addsLeft=snap.addsLeft;
  chain=[]; chainDir=null;
  clearHint();
  render();
  setMsg('1æ‰‹ã‚‚ã©ã£ãŸã‚ˆï¼','ok');
  document.getElementById('undoBtn').disabled=undoStack.length===0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleHint(){
  if(hintActive){ clearHint(); return; }
  hintMove=findHintMove();
  if(!hintMove||hintMove.length===0){
    setMsg('ãƒ’ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸâ€¦è¡Œè¿½åŠ ã—ã¦ã¿ã‚ˆã†ï¼','err');
    return;
  }
  hintActive=true;
  document.getElementById('hintBtn').classList.add('active');
  render();
  const cnt=hintMove.length;
  const vals=hintMove.map(p=>grid[p.r][p.c]);
  const sum=vals.reduce((a,b)=>a+b,0);
  const desc=vals[0]===vals[1]&&cnt===2?`${vals[0]}ã¨${vals[0]}`:`${vals.join('+')}=${sum}`;
  setMsg(`ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼š${desc} ã‚’æ¶ˆãã†ï¼`,'ok');
}

function clearHint(){
  hintActive=false; hintMove=null;
  document.getElementById('hintBtn').classList.remove('active');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WIN / LOSE CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkWin(){
  const allGone=grid.length===0||grid.every(row=>row.every(v=>v===null));
  if(allGone){ showOverlay('clear'); return; }
  if(addsLeft<=0&&allMovesOnGrid(grid).length===0){ showOverlay('over'); }
}

function showOverlay(mode){
  overlayMode=mode;
  const E=document.getElementById('ovEmoji');
  const T=document.getElementById('ovTitle');
  const S=document.getElementById('ovSub');
  const B=document.getElementById('ovBtn');
  if(mode==='clear'){
    E.textContent='ğŸ‰ğŸŒˆğŸ‰'; T.textContent='ã‚¯ãƒªã‚¢ï¼';
    S.innerHTML=`ã‚¹ãƒ†ãƒ¼ã‚¸ ${stage} ã‚¯ãƒªã‚¢ï¼<br>ã‚¹ã‚³ã‚¢ï¼š${score}ç‚¹<br>ã¤ãã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸ã©ã†ãï¼`;
    B.textContent='ã¤ãã¸ï¼';
    const flash=document.createElement('div'); flash.className='stage-flash';
    document.body.appendChild(flash); setTimeout(()=>flash.remove(),700);
    bigConfetti(22);
  } else {
    E.textContent='ğŸ˜¢ğŸ¾ğŸ˜¢'; T.textContent='ã–ã‚“ã­ã‚“â€¦';
    S.innerHTML=`ãƒšã‚¢ãŒãªããªã£ã¦ã—ã¾ã£ãŸï¼<br>ã‚¹ã‚³ã‚¢ï¼š${score}ç‚¹<br>â†©ã‚‚ã©ã‚‹ã‹ã€ãƒªã‚»ãƒƒãƒˆã—ã‚ˆã†ï¼`;
    B.textContent='ã‚‚ã†ã„ã¡ã©ï¼';
  }
  setTimeout(()=>document.getElementById('overlay').classList.add('show'),
    mode==='clear'?500:200);
}

function overlayAction(){
  document.getElementById('overlay').classList.remove('show');
  if(overlayMode==='clear'){ stage++; }
  startStage();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOARD GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function rndInt(){ return 1+Math.floor(Math.random()*9); }

function makeRow(pairRate, prevRow){
  const row=[];
  for(let c=0;c<COLS;c++){
    let v;
    // Try to pair with prev row same column (vertical pair)
    const above=prevRow?prevRow[c]:null;
    if(above!==null&&Math.random()<pairRate*0.5){
      const comp=10-above;
      v=(comp>=1&&comp<=9)?comp:above;
    } else if(c>0&&Math.random()<pairRate){
      const left=row[c-1];
      const comp=10-left;
      v=(Math.random()<0.5&&comp>=1&&comp<=9)?comp:left;
    } else {
      v=rndInt();
    }
    // Prevent 3 identical in a row
    if(c>=2&&row[c-2]===v&&row[c-1]===v) v=((v)%9)+1;
    // Prevent 2 identical consecutive UNLESS it forms a valid same-pair
    // (actually same-pair IS valid, so allow it)
    row.push(v);
  }
  return row;
}

function buildInitialGrid(cfg){
  for(let att=0;att<30;att++){
    const g=[];
    for(let r=0;r<cfg.rows;r++) g.push(makeRow(cfg.pairRate,r>0?g[r-1]:null));
    if(allMovesOnGrid(g).length>=3) return g;
  }
  // Fallback
  const g=[];
  for(let r=0;r<cfg.rows;r++) g.push(makeRow(0.5,r>0?g[r-1]:null));
  g[0][0]=5; g[0][1]=5;
  return g;
}

function buildAddRows(count){
  const newRows=[];
  for(let ri=0;ri<count;ri++){
    const isLast=ri===count-1;
    const fillCount=isLast?(6+Math.floor(Math.random()*(COLS-5))):COLS;
    const prevRow=ri>0?newRows[ri-1]:(grid.length>0?grid[grid.length-1]:null);
    const row=[];
    for(let c=0;c<COLS;c++){
      row.push(c<fillCount?rndInt():null);
    }
    newRows.push(row);
  }

  // Inject pairable values
  const allRows=[...grid.map(r=>[...r]),...newRows.map(r=>[...r])];
  const totalRows=allRows.length;
  const newStart=grid.length;

  for(let ri=newStart;ri<totalRows;ri++){
    for(let c=0;c<COLS;c++){
      if(allRows[ri][c]===null) continue;
      if(Math.random()>0.65) continue;
      // gather alive neighbor values
      const nbVals=[];
      for(const [dr,dc] of DIRS8){
        const f=walkAlive(allRows,ri,c,dr,dc);
        if(f){
          const v=allRows[f.r][f.c];
          if(typeof v==='number'&&v>=1&&v<=9) nbVals.push(v);
        }
      }
      if(nbVals.length===0) continue;
      const target=nbVals[Math.floor(Math.random()*nbVals.length)];
      const comp=10-target;
      let partner=Math.random()<0.55&&comp>=1&&comp<=9?comp:target;
      if(partner<1||partner>9) partner=target;
      // prevent 3 identical in a row
      if(c>=2&&allRows[ri][c-1]===partner&&allRows[ri][c-2]===partner)
        partner=((partner)%9)+1;
      allRows[ri][c]=partner;
    }
  }
  return newRows.map((_,i)=>allRows[newStart+i]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SOLVABILITY CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isSolvable(g,cfg){
  if(allMovesOnGrid(g).length===0) return false;
  // simulate adding a couple rows
  const sim=g.map(r=>[...r]);
  for(let a=0;a<Math.min(cfg.adds,2);a++){
    const row=[]; for(let c=0;c<COLS;c++) row.push(rndInt());
    sim.push(row);
    if(allMovesOnGrid(sim).length===0) return false;
  }
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  START STAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startStage(){
  const cfg=stageCfg(stage);
  const {cols}=calcCols();
  COLS=cols;

  let g, att=0;
  do { g=buildInitialGrid(cfg); att++; }
  while(!isSolvable(g,cfg)&&att<15);

  grid=g; chain=[]; chainDir=null;
  score=0; pairs=0; addsLeft=cfg.adds;
  undoStack=[]; busy=false;
  clearHint();

  document.getElementById('stageBanner').textContent=`ã‚¹ãƒ†ãƒ¼ã‚¸ ${stage}`;
  document.getElementById('undoBtn').disabled=true;
  render(); updateStats();
  setMsg('ã™ããªæ•°å­—ã‚’ãˆã‚‰ã‚“ã§ã­ï¼','');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStats(){
  document.getElementById('scoreVal').textContent=score;
  document.getElementById('pairsVal').textContent=pairs;
  const av=document.getElementById('addVal');
  av.textContent=addsLeft;
  av.className='pill-val'+(addsLeft<=1?' warn':addsLeft>=4?' ok':'');
  document.getElementById('addBtn').disabled=addsLeft<=0;
}

function setMsg(text,type=''){
  const el=document.getElementById('msg');
  el.textContent=text; el.className='msg'+(type?' '+type:'');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EFFECTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawnConf(el){
  if(!el) return;
  const rect=el.getBoundingClientRect();
  const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
  for(let i=0;i<5;i++){
    const d=document.createElement('div'); d.className='conf';
    d.textContent=CONF_CHARS[Math.floor(Math.random()*CONF_CHARS.length)];
    d.style.left=cx+'px'; d.style.top=cy+'px';
    const ang=Math.random()*Math.PI*2, dist=44+Math.random()*54;
    d.style.setProperty('--dx',Math.cos(ang)*dist+'px');
    d.style.setProperty('--dy',Math.sin(ang)*dist+'px');
    d.style.setProperty('--rot',Math.random()*360+'deg');
    d.style.animationDelay=Math.random()*0.07+'s';
    document.body.appendChild(d); setTimeout(()=>d.remove(),950);
  }
}

function bigConfetti(n){
  for(let i=0;i<n;i++){
    setTimeout(()=>{
      const d=document.createElement('div'); d.className='conf'; d.style.fontSize='24px';
      d.textContent=CONF_CHARS[Math.floor(Math.random()*CONF_CHARS.length)];
      d.style.left=Math.random()*window.innerWidth+'px';
      d.style.top=Math.random()*window.innerHeight+'px';
      const ang=Math.random()*Math.PI*2, dist=80+Math.random()*110;
      d.style.setProperty('--dx',Math.cos(ang)*dist+'px');
      d.style.setProperty('--dy',Math.sin(ang)*dist+'px');
      d.style.setProperty('--rot',Math.random()*720+'deg');
      document.body.appendChild(d); setTimeout(()=>d.remove(),1000);
    },i*55);
  }
}

function spawnFloatText(text,x,y,color){
  const el=document.createElement('div'); el.className='float-text';
  el.textContent=text; el.style.left=x+'px'; el.style.top=y+'px';
  el.style.color=color||'#9960cc'; el.style.transform='translateX(-50%)';
  document.body.appendChild(el); setTimeout(()=>el.remove(),1000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMALS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const STICKER_DEFS=[
  {type:'chick',left:'3%', top:'7%', delay:0},
  {type:'duck', left:'88%',top:'4%', delay:1.2},
  {type:'dog',  left:'3%', top:'56%',delay:0.7},
  {type:'cat',  left:'87%',top:'60%',delay:1.8},
  {type:'chick',left:'44%',top:'1%', delay:2.1},
  {type:'duck', left:'16%',top:'83%',delay:0.4},
  {type:'cat',  left:'70%',top:'81%',delay:1.5},
  {type:'dog',  left:'52%',top:'86%',delay:2.6},
];
const SZ=68;

function initStickers(){
  const stage=document.getElementById('animalStage');
  stage.innerHTML='';
  STICKER_DEFS.forEach(def=>{
    const wrap=document.createElement('div'); wrap.className='sticker';
    wrap.style.left=def.left; wrap.style.top=def.top;
    wrap.style.width=SZ+'px'; wrap.style.height=SZ+'px';
    wrap.innerHTML=SVGS[def.type](SZ);
    const dur=(3.4+Math.random()*2.4).toFixed(1);
    wrap.style.animation=`sFloat ${dur}s ease-in-out ${def.delay}s infinite`;
    wrap.addEventListener('click',()=>{
      wrap.classList.remove('wiggling','bouncing'); void wrap.offsetWidth;
      wrap.classList.add('bouncing');
      setTimeout(()=>wrap.classList.remove('bouncing'),580);
    });
    wrap.addEventListener('mouseenter',()=>{ if(!wrap.classList.contains('bouncing')) wrap.classList.add('wiggling'); });
    wrap.addEventListener('mouseleave',()=>wrap.classList.remove('wiggling'));
    stage.appendChild(wrap);
  });
}

document.addEventListener('mousemove',e=>{
  document.querySelectorAll('.sticker').forEach(s=>{
    if(s.classList.contains('bouncing')) return;
    const rect=s.getBoundingClientRect();
    const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
    const dx=e.clientX-cx, dy=e.clientY-cy;
    const dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<100){
      const sc=1+(1-dist/100)*0.27;
      s.style.transform=`scale(${sc}) translate(${-dx*0.045}px,${-dy*0.045}px)`;
    } else { s.style.transform=''; }
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MISC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleRules(){ document.getElementById('rulesPanel').classList.toggle('open'); }

function resetGame(){
  document.getElementById('overlay').classList.remove('show');
  score=0; pairs=0; stage=1;
  startStage();
}

window.addEventListener('resize',()=>{
  const {cols}=calcCols();
  if(cols!==COLS){ COLS=cols; }
  render();
});

// â”€â”€ BOOT â”€â”€
initStickers();
startStage();
</script>
</body>
</html>
