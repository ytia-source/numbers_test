<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ğŸŒ¸ ãªã‹ã‚ˆã—ãƒŠãƒ³ãƒãƒ¼ã‚º</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700;800;900&display=swap');

:root {
  --cell: 52px;
  --gap: 4px;
  --radius: 13px;
  --panel-bg: rgba(255,255,255,0.87);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Nunito', sans-serif;
  min-height: 100vh;
  background: linear-gradient(160deg, #fff0f8 0%, #f0eaff 30%, #e8f5ff 60%, #f0fff4 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px 6px 40px;
  overflow-x: hidden;
  position: relative;
}

/* â”€â”€ ANIMAL STAGE â”€â”€ */
.animal-stage {
  position: fixed; inset: 0;
  pointer-events: none; z-index: 0; overflow: hidden;
}
.sticker {
  position: absolute; pointer-events: all; cursor: pointer; user-select: none;
  filter: drop-shadow(0 4px 10px rgba(0,0,0,0.11));
}
.sticker svg { display: block; overflow: visible; }
@keyframes sFloat {
  0%,100% { transform: translateY(0) rotate(0deg); }
  30%      { transform: translateY(-9px) rotate(2.5deg); }
  70%      { transform: translateY(-5px) rotate(-2.5deg); }
}
@keyframes sBounce {
  0%   { transform: scale(1); }
  20%  { transform: scale(1.35) rotate(-12deg); }
  55%  { transform: scale(0.88) rotate(8deg) translateY(-12px); }
  80%  { transform: scale(1.08) rotate(-3deg); }
  100% { transform: scale(1) rotate(0); }
}
@keyframes sWiggle {
  0%,100% { transform: rotate(0) scale(1.15); }
  30%      { transform: rotate(-8deg) scale(1.18); }
  70%      { transform: rotate(8deg) scale(1.18); }
}
.sticker.wiggling { animation: sWiggle 0.38s ease !important; }
.sticker.bouncing { animation: sBounce 0.52s cubic-bezier(.36,.07,.19,.97) !important; }

/* â”€â”€ TITLE â”€â”€ */
.title-wrap { position: relative; z-index: 1; text-align: center; margin-bottom: 8px; }
h1 {
  font-family: 'Fredoka One', cursive;
  font-size: clamp(22px, 5vw, 40px);
  background: linear-gradient(135deg, #ff5fa0, #b05fff, #5fb0ff);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
  line-height: 1.1;
}
.title-sub { font-size: 11px; color: #c090d8; font-weight: 800; letter-spacing: 1px; }

/* â”€â”€ GAME PANEL â”€â”€ */
.game-panel {
  position: relative; z-index: 1;
  background: var(--panel-bg);
  backdrop-filter: blur(14px);
  border-radius: 22px;
  padding: 14px 12px 12px;
  box-shadow: 0 8px 32px rgba(180,130,220,0.16), 0 0 0 2px rgba(255,255,255,0.9);
  width: 100%; max-width: 700px;
}

/* â”€â”€ STATS BAR â”€â”€ */
.stats-bar {
  display: flex; align-items: center; gap: 6px;
  margin-bottom: 10px; flex-wrap: wrap; justify-content: space-between;
}
.pill {
  display: flex; align-items: center; gap: 5px;
  background: linear-gradient(135deg, #fff0f8, #f4eeff);
  border-radius: 50px; padding: 4px 11px;
  box-shadow: 0 2px 7px rgba(200,140,220,0.14);
  border: 2px solid rgba(255,255,255,0.85);
}
.pill-icon { font-size: 14px; }
.pill-texts { display: flex; flex-direction: column; line-height: 1.1; }
.pill-label { font-size: 8px; font-weight: 900; color: #c08ad8; letter-spacing: 1px; text-transform: uppercase; }
.pill-val { font-family: 'Fredoka One', cursive; font-size: 17px; color: #9060cc; }
.pill-val.warn { color: #ee5555; }
.pill-val.ok   { color: #44bb66; }

.hdr-btn {
  font-family: 'Fredoka One', cursive; font-size: 13px;
  border-radius: 50px; cursor: pointer; padding: 5px 13px;
  border: 2px solid rgba(255,255,255,0.8);
  transition: transform 0.17s cubic-bezier(.34,1.56,.64,1);
}
.hdr-btn:hover { transform: scale(1.07) translateY(-1px); }
.rules-btn { background: linear-gradient(135deg,#ffe0f2,#e8d4ff); color: #aa66cc;
  box-shadow: 0 3px 9px rgba(200,130,220,0.18); }
.reset-btn { background: linear-gradient(135deg,#d4ecff,#c8e8ff); color: #4488cc;
  box-shadow: 0 3px 9px rgba(100,160,220,0.18); }

/* â”€â”€ RULES â”€â”€ */
.rules-panel {
  background: linear-gradient(135deg,rgba(255,235,248,0.9),rgba(235,225,255,0.9));
  border-radius: 14px; padding: 10px 14px; margin-bottom: 10px;
  font-size: 11px; line-height: 2; color: #9a77b0;
  border: 2px solid rgba(255,255,255,0.7); display: none;
}
.rules-panel.open { display: block; }
.rules-panel b { color: #cc55aa; }

/* â”€â”€ STAGE BANNER â”€â”€ */
.stage-banner {
  text-align: center; font-family: 'Fredoka One', cursive;
  font-size: 13px; color: #b070d8;
  margin-bottom: 6px; letter-spacing: 1px;
}

/* â”€â”€ GRID â”€â”€ */
.grid-scroll { overflow: visible; margin-bottom: 10px; }
#gridWrap { display: flex; flex-direction: column; gap: var(--gap); }

.grid-row { display: flex; gap: var(--gap); transition: opacity 0.3s; }
.grid-row.row-vanish { animation: rowPoof 0.5s cubic-bezier(.36,.07,.19,.97) forwards; }
@keyframes rowPoof {
  0%   { transform: scaleY(1); opacity: 1; filter: brightness(1); }
  35%  { transform: scaleY(1.05); opacity: 1; filter: brightness(1.8) saturate(2.5); }
  100% { transform: scaleY(0); opacity: 0; }
}

/* â”€â”€ CELLS â”€â”€ */
.cell {
  height: var(--cell);
  border-radius: var(--radius);
  display: flex; align-items: center; justify-content: center;
  font-family: 'Fredoka One', cursive; font-size: 20px;
  cursor: pointer; user-select: none;
  border: 2px solid rgba(255,255,255,0.72);
  box-shadow: 0 3px 7px rgba(0,0,0,0.09), 0 1px 0 rgba(255,255,255,0.88) inset;
  transition: transform 0.12s cubic-bezier(.34,1.56,.64,1), box-shadow 0.12s, filter 0.12s;
  position: relative; overflow: hidden; flex-shrink: 0;
}
.cell::after {
  content:''; position:absolute; top:3px; left:10px; right:10px; height:32%;
  background:rgba(255,255,255,0.42); border-radius:50%; pointer-events:none;
}
.cell[data-v="1"]{ background:linear-gradient(145deg,#ffc8dd,#ff90b8); color:#c0245e; }
.cell[data-v="2"]{ background:linear-gradient(145deg,#ffdcb0,#ffb870); color:#aa4408; }
.cell[data-v="3"]{ background:linear-gradient(145deg,#fff4a0,#ffe040); color:#887000; }
.cell[data-v="4"]{ background:linear-gradient(145deg,#b8f5b8,#70e870); color:#1a7a1a; }
.cell[data-v="5"]{ background:linear-gradient(145deg,#a8f0e4,#50dcc4); color:#107860; }
.cell[data-v="6"]{ background:linear-gradient(145deg,#aadefc,#60c0ff); color:#1058b0; }
.cell[data-v="7"]{ background:linear-gradient(145deg,#ccc0ff,#9980ff); color:#3818b8; }
.cell[data-v="8"]{ background:linear-gradient(145deg,#f8b8f0,#f070e0); color:#a01090; }
.cell[data-v="9"]{ background:linear-gradient(145deg,#ffc8b0,#ff9870); color:#b02808; }

.cell:hover:not(.dead):not(.sel):not(.popping) {
  transform: translateY(-4px) scale(1.1);
  box-shadow: 0 8px 18px rgba(0,0,0,0.13); filter: brightness(1.06); z-index: 2;
}
.cell.sel {
  transform: translateY(-5px) scale(1.12);
  box-shadow: 0 0 0 3.5px #ff66bb, 0 8px 22px rgba(255,80,180,0.4); z-index: 3;
  animation: selPulse 0.55s ease infinite alternate;
}
@keyframes selPulse {
  from { box-shadow: 0 0 0 3px #ff66bb, 0 6px 18px rgba(255,80,180,0.3); }
  to   { box-shadow: 0 0 0 5px #ffaadd, 0 10px 28px rgba(255,80,180,0.5); }
}
.cell.popping { animation: cellPop 0.42s cubic-bezier(.36,.07,.19,.97) forwards; }
@keyframes cellPop {
  0%   { transform:scale(1); opacity:1; }
  35%  { transform:scale(1.4) rotate(12deg); opacity:1; filter:brightness(1.8); }
  100% { transform:scale(0) rotate(-15deg); opacity:0; }
}
.cell.dead {
  background: linear-gradient(145deg,#eeecf2,#e6e2ea) !important;
  color: transparent !important; border-color: rgba(210,200,215,0.25) !important;
  box-shadow: none !important; cursor: default; opacity: 0.38;
}
.cell.dead::after { display: none; }
.cell.new-appear { animation: newBounce 0.36s cubic-bezier(.34,1.56,.64,1) both; }
@keyframes newBounce {
  0%   { transform:scale(0) translateY(-14px); opacity:0; }
  65%  { transform:scale(1.1) translateY(0); opacity:1; }
  100% { transform:scale(1); opacity:1; }
}

/* â”€â”€ BOTTOM BAR â”€â”€ */
.bottom-bar {
  display: flex; align-items: center; gap: 8px; flex-wrap: wrap; justify-content: space-between;
}
.add-btn {
  font-family: 'Fredoka One', cursive; font-size: 14px;
  padding: 9px 18px; border-radius: 50px; cursor: pointer;
  background: linear-gradient(135deg,#ffb0d8,#d090ff); color: white;
  border: 2.5px solid rgba(255,255,255,0.72);
  box-shadow: 0 4px 13px rgba(220,120,200,0.36);
  transition: transform 0.17s cubic-bezier(.34,1.56,.64,1), box-shadow 0.17s, opacity 0.2s;
  text-shadow: 0 1px 3px rgba(160,50,140,0.32);
}
.add-btn:hover:not(:disabled) { transform:scale(1.07) translateY(-2px); box-shadow:0 7px 18px rgba(220,120,200,0.5); }
.add-btn:active { transform:scale(0.95); }
.add-btn:disabled { opacity: 0.4; cursor: not-allowed; }

.msg { flex:1; text-align:center; font-size:12px; font-weight:800; color:#c08ad8;
  min-height:18px; transition:color 0.2s; }
.msg.err { color:#ff5577; }
.msg.ok  { color:#44bb77; }
.msg.wow { color:#ff8800; }
.msg.bonus { color:#9933ff; }

/* â”€â”€ FLOATING SCORE TEXT â”€â”€ */
.float-text {
  position:fixed; pointer-events:none; z-index:500;
  font-family:'Fredoka One',cursive; font-size:22px;
  white-space:nowrap; user-select:none;
  animation: floatUp 0.95s ease forwards;
}
@keyframes floatUp {
  0%   { opacity:1; transform:translateY(0) scale(1); }
  70%  { opacity:1; transform:translateY(-55px) scale(1.1); }
  100% { opacity:0; transform:translateY(-80px) scale(0.8); }
}

/* â”€â”€ CONFETTI â”€â”€ */
.conf {
  position:fixed; pointer-events:none; z-index:600; font-size:18px;
  animation: confFly 0.9s ease forwards;
}
@keyframes confFly {
  0%   { opacity:1; transform:translate(0,0) scale(1) rotate(0); }
  100% { opacity:0; transform:translate(var(--dx),var(--dy)) scale(0.2) rotate(var(--rot)); }
}

/* â”€â”€ OVERLAY (stage clear / game over) â”€â”€ */
.overlay {
  display:none; position:fixed; inset:0;
  background:rgba(255,230,248,0.65); backdrop-filter:blur(8px);
  z-index:800; align-items:center; justify-content:center;
}
.overlay.show { display:flex; }
.ov-box {
  background:white; border-radius:26px;
  padding:34px 46px; text-align:center;
  box-shadow:0 16px 55px rgba(200,100,200,0.25);
  border:3px solid rgba(255,200,235,0.5);
  max-width:340px; width:90%;
}
.ov-emoji { font-size:46px; margin-bottom:8px; }
.ov-title {
  font-family:'Fredoka One',cursive; font-size:38px;
  background:linear-gradient(135deg,#ff5fa0,#a060ff);
  -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
  margin-bottom:5px;
}
.ov-sub  { color:#c090d8; font-size:12px; font-weight:800; margin-bottom:18px; line-height:1.8; }
.ov-btn {
  font-family:'Fredoka One',cursive; font-size:17px;
  padding:11px 30px; border-radius:50px; cursor:pointer;
  background:linear-gradient(135deg,#ffb0d8,#d090ff);
  color:white; border:3px solid rgba(255,255,255,0.8);
  box-shadow:0 5px 15px rgba(220,120,200,0.38);
  transition:transform 0.17s cubic-bezier(.34,1.56,.64,1);
}
.ov-btn:hover { transform:scale(1.07); }

/* â”€â”€ STAGE CLEAR FLASH â”€â”€ */
.stage-flash {
  position:fixed; inset:0; z-index:750; pointer-events:none;
  background:white; opacity:0;
  animation:flashIn 0.6s ease forwards;
}
@keyframes flashIn {
  0%   { opacity:0; }
  30%  { opacity:0.7; }
  100% { opacity:0; }
}
</style>
</head>
<body>

<div class="animal-stage" id="animalStage"></div>

<div class="title-wrap">
  <h1>ğŸŒ¸ ãªã‹ã‚ˆã—ãƒŠãƒ³ãƒãƒ¼ã‚º</h1>
  <p class="title-sub">ã¿ã‚“ãªã§ãªã‹ã‚ˆã ããˆã¡ã‚ƒãŠã†â™ª</p>
</div>

<div class="game-panel">
  <div class="stats-bar">
    <div class="pill">
      <span class="pill-icon">â­</span>
      <div class="pill-texts"><span class="pill-label">SCORE</span><span class="pill-val" id="scoreVal">0</span></div>
    </div>
    <div class="pill">
      <span class="pill-icon">ğŸ’•</span>
      <div class="pill-texts"><span class="pill-label">PAIRS</span><span class="pill-val" id="pairsVal">0</span></div>
    </div>
    <div class="pill" id="addPill">
      <span class="pill-icon">â•</span>
      <div class="pill-texts"><span class="pill-label">ADD</span><span class="pill-val" id="addVal">5</span></div>
    </div>
    <button class="hdr-btn rules-btn" onclick="toggleRules()">ğŸŒ¸ ãƒ«ãƒ¼ãƒ«</button>
    <button class="hdr-btn reset-btn" onclick="resetGame()">â†º ãƒªã‚»ãƒƒãƒˆ</button>
  </div>

  <div class="rules-panel" id="rulesPanel">
    ğŸ£ ç¸¦ãƒ»æ¨ªãƒ»æ–œã‚ã«<b>éš£æ¥ã™ã‚‹2ã¤ã®æ•°å­—</b>ã‚’é †ã«ã‚¯ãƒªãƒƒã‚¯ï¼<br>
    ğŸ’• <b>åŒã˜æ•°å­—</b>ã¾ãŸã¯<b>åˆè¨ˆ10</b>ã«ãªã‚‹ãƒšã‚¢ãŒæ¶ˆãˆã‚‹ã‚ˆâœ¨<br>
    ğŸ¾ æ¶ˆãˆãŸç©´ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¦éš£æ¥åˆ¤å®šï¼ˆ<b>1â–«â–«1</b>â†’ä¸¡ç«¯ã®1ã¯éš£æ¥ï¼‰<br>
    ğŸ¦† <b>è¡Œã®å³ç«¯</b>ã¯<b>æ¬¡ã®è¡Œã®å·¦ç«¯</b>ã«éš£æ¥ã—ã¦ã‚‹ã‚ˆï¼<br>
    ğŸ“ <b>é›¢ã‚ŒãŸãƒšã‚¢</b>ã»ã©ãƒœãƒ¼ãƒŠã‚¹ç‚¹ãŒå¤§ãã„ã‚ˆï¼<br>
    ğŸŒˆ <b>1è¡Œã¾ã‚‹ã”ã¨æ¶ˆãˆã‚‹ã¨</b>è¡Œãƒœãƒ¼ãƒŠã‚¹â™ª<br>
    â• <b>è¡Œè¿½åŠ </b>ã¯å›æ•°åˆ¶é™ã‚ã‚Šã€‚ä¸Šæ‰‹ã«ä½¿ãŠã†ï¼<br>
    ğŸ† å…¨éƒ¨æ¶ˆã—ãŸã‚‰<b>ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢</b>ï¼æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸ï¼
  </div>

  <div class="stage-banner" id="stageBanner">ã‚¹ãƒ†ãƒ¼ã‚¸ 1</div>

  <div class="grid-scroll">
    <div id="gridWrap"></div>
  </div>

  <div class="bottom-bar">
    <button class="add-btn" id="addBtn" onclick="addRows()">ï¼‹ è¡Œè¿½åŠ </button>
    <span class="msg" id="msg">ã™ããªæ•°å­—ã‚’ãˆã‚‰ã‚“ã§ã­ï¼</span>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="ov-box">
    <div class="ov-emoji" id="ovEmoji">ğŸ‰</div>
    <div class="ov-title" id="ovTitle">ã™ã”ã„ï¼</div>
    <div class="ov-sub"  id="ovSub">ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼</div>
    <button class="ov-btn" id="ovBtn" onclick="overlayAction()">ã¤ãã¸ï¼</button>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMAL SVGs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SVGS = {
  chick: (s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="40" cy="52" rx="22" ry="20" fill="#FFE066" stroke="#E8A800" stroke-width="2"/>
    <circle cx="40" cy="28" r="18" fill="#FFE566" stroke="#E8A800" stroke-width="2"/>
    <ellipse cx="20" cy="54" rx="9" ry="6" fill="#FFD022" stroke="#E8A800" stroke-width="1.5" transform="rotate(-20 20 54)"/>
    <ellipse cx="60" cy="54" rx="9" ry="6" fill="#FFD022" stroke="#E8A800" stroke-width="1.5" transform="rotate(20 60 54)"/>
    <ellipse cx="40" cy="33" rx="5" ry="3.5" fill="#FF9922" stroke="#DD7700" stroke-width="1.5"/>
    <circle cx="33" cy="24" r="4" fill="white"/><circle cx="33" cy="24" r="2.5" fill="#222"/><circle cx="34" cy="23" r="1" fill="white"/>
    <circle cx="47" cy="24" r="4" fill="white"/><circle cx="47" cy="24" r="2.5" fill="#222"/><circle cx="48" cy="23" r="1" fill="white"/>
    <ellipse cx="28" cy="30" rx="4" ry="2.5" fill="#FFB0B0" opacity="0.7"/>
    <ellipse cx="52" cy="30" rx="4" ry="2.5" fill="#FFB0B0" opacity="0.7"/>
    <line x1="34" y1="70" x2="30" y2="76" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="34" y1="70" x2="34" y2="77" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="46" y1="70" x2="42" y2="76" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="46" y1="70" x2="46" y2="77" stroke="#FF9922" stroke-width="2.5" stroke-linecap="round"/>
  </svg>`,

  dog: (s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="20" cy="22" rx="10" ry="14" fill="#D4956A" stroke="#A06030" stroke-width="1.5" transform="rotate(-15 20 22)"/>
    <ellipse cx="60" cy="22" rx="10" ry="14" fill="#D4956A" stroke="#A06030" stroke-width="1.5" transform="rotate(15 60 22)"/>
    <circle cx="40" cy="32" r="22" fill="#E8B080" stroke="#A06030" stroke-width="2"/>
    <ellipse cx="40" cy="62" rx="18" ry="14" fill="#E8B080" stroke="#A06030" stroke-width="2"/>
    <ellipse cx="40" cy="40" rx="12" ry="9" fill="#F5CFA0"/>
    <ellipse cx="40" cy="35" rx="5" ry="3.5" fill="#442200"/>
    <ellipse cx="41" cy="34" rx="1.5" ry="1" fill="white" opacity="0.5"/>
    <path d="M34 42 Q40 47 46 42" stroke="#A06030" stroke-width="1.8" fill="none" stroke-linecap="round"/>
    <circle cx="31" cy="27" r="4.5" fill="white"/><circle cx="31" cy="27" r="3" fill="#3a1800"/><circle cx="32.5" cy="25.5" r="1.2" fill="white"/>
    <circle cx="49" cy="27" r="4.5" fill="white"/><circle cx="49" cy="27" r="3" fill="#3a1800"/><circle cx="50.5" cy="25.5" r="1.2" fill="white"/>
    <ellipse cx="24" cy="36" rx="5" ry="3" fill="#FFB0A0" opacity="0.6"/>
    <ellipse cx="56" cy="36" rx="5" ry="3" fill="#FFB0A0" opacity="0.6"/>
    <path d="M56 62 Q70 50 66 42" stroke="#E8B080" stroke-width="6" fill="none" stroke-linecap="round"/>
    <path d="M56 62 Q70 50 66 42" stroke="#A06030" stroke-width="2" fill="none" stroke-linecap="round"/>
  </svg>`,

  cat: (s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <polygon points="14,28 22,8 30,28" fill="#FFAACC" stroke="#D06080" stroke-width="1.5" stroke-linejoin="round"/>
    <polygon points="18,26 22,13 28,26" fill="#FFD4E8"/>
    <polygon points="50,28 58,8 66,28" fill="#FFAACC" stroke="#D06080" stroke-width="1.5" stroke-linejoin="round"/>
    <polygon points="52,26 58,13 64,26" fill="#FFD4E8"/>
    <circle cx="40" cy="36" r="22" fill="#FFBBDD" stroke="#D06080" stroke-width="2"/>
    <ellipse cx="40" cy="64" rx="17" ry="13" fill="#FFBBDD" stroke="#D06080" stroke-width="2"/>
    <line x1="14" y1="38" x2="30" y2="40" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <line x1="14" y1="42" x2="30" y2="42" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <line x1="50" y1="40" x2="66" y2="38" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <line x1="50" y1="42" x2="66" y2="42" stroke="#C06070" stroke-width="1.2" opacity="0.7"/>
    <ellipse cx="40" cy="43" rx="10" ry="7" fill="#FFD8EC"/>
    <path d="M38 39 L42 39 L40 41 Z" fill="#FF6699"/>
    <path d="M37 42 Q40 46 43 42" stroke="#D06080" stroke-width="1.5" fill="none" stroke-linecap="round"/>
    <ellipse cx="31" cy="32" rx="4.5" ry="5" fill="white"/><ellipse cx="31" cy="32" rx="2.5" ry="4" fill="#2a0a1a"/><circle cx="32" cy="30" r="1.2" fill="white"/>
    <ellipse cx="49" cy="32" rx="4.5" ry="5" fill="white"/><ellipse cx="49" cy="32" rx="2.5" ry="4" fill="#2a0a1a"/><circle cx="50" cy="30" r="1.2" fill="white"/>
    <ellipse cx="24" cy="40" rx="5" ry="3" fill="#FFB0C8" opacity="0.55"/>
    <ellipse cx="56" cy="40" rx="5" ry="3" fill="#FFB0C8" opacity="0.55"/>
    <path d="M55 70 Q72 68 70 55 Q68 44 62 46" stroke="#FFBBDD" stroke-width="6" fill="none" stroke-linecap="round"/>
    <path d="M55 70 Q72 68 70 55 Q68 44 62 46" stroke="#D06080" stroke-width="2" fill="none" stroke-linecap="round"/>
  </svg>`,

  duck: (s)=>`<svg width="${s}" height="${s}" viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="42" cy="56" rx="24" ry="18" fill="#AADDFF" stroke="#5599CC" stroke-width="2"/>
    <ellipse cx="52" cy="54" rx="14" ry="9" fill="#88CCFF" stroke="#5599CC" stroke-width="1.5" transform="rotate(15 52 54)"/>
    <circle cx="28" cy="30" r="17" fill="#AADDFF" stroke="#5599CC" stroke-width="2"/>
    <path d="M14 29 Q8 30 8 34 Q8 37 14 37 L20 33 Z" fill="#FFCC44" stroke="#CC8800" stroke-width="1.5" stroke-linejoin="round"/>
    <ellipse cx="13" cy="36" rx="6" ry="2.5" fill="#FFAA22" stroke="#CC8800" stroke-width="1"/>
    <circle cx="24" cy="24" r="4.5" fill="white"/><circle cx="24" cy="24" r="3" fill="#1a1a2a"/><circle cx="25.5" cy="22.5" r="1.2" fill="white"/>
    <path d="M28 14 Q32 4 36 12" stroke="#88CCFF" stroke-width="3" fill="none" stroke-linecap="round"/>
    <ellipse cx="20" cy="32" rx="4" ry="2.5" fill="#FFB0D0" opacity="0.6"/>
    <path d="M32 72 Q28 76 24 76 M32 72 Q31 76 27 78 M32 72 L32 78" stroke="#FFCC44" stroke-width="2.5" fill="none" stroke-linecap="round"/>
    <path d="M50 72 Q46 76 42 76 M50 72 Q49 76 45 78 M50 72 L50 78" stroke="#FFCC44" stroke-width="2.5" fill="none" stroke-linecap="round"/>
    <path d="M34 42 Q36 50 42 54" stroke="#AADDFF" stroke-width="8" fill="none" stroke-linecap="round"/>
    <path d="M34 42 Q36 50 42 54" stroke="#5599CC" stroke-width="2" fill="none" stroke-linecap="round"/>
  </svg>`
};

const CONF_CHARS = ['âœ¨','ğŸ’«','ğŸŒ¸','â­','ğŸ’•','ğŸ€','ğŸŒŸ','ğŸ’–','ğŸ¬','ğŸŠ','ğŸŒˆ','ğŸ¦‹'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let COLS = 8;          // calculated from screen width
const CELL_MIN_PX = 38;
const CELL_MAX_PX = 56;
const GAP_PX = 4;
const PANEL_PADDING = 24; // each side

let grid = [];
let selected = null;
let score = 0;
let pairs = 0;
let stage = 1;
let addsLeft = 0;
let busy = false;
let overlayMode = 'clear'; // 'clear' | 'over'

// â”€â”€ Stage config â”€â”€
function stageConfig(s) {
  return {
    rows:    Math.min(3 + Math.floor((s-1)/2), 6),  // 3â†’4â†’5â†’6 rows as stage increases
    adds:    Math.max(7 - s, 2),                      // 6,5,4,3,2,2 â€¦
    // pair density: lower = harder (fewer easy adjacent same-row pairs)
    pairRate: Math.max(0.55 - (s-1)*0.05, 0.25),
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COLUMN COUNT from screen
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calcCols() {
  const panelW = Math.min(window.innerWidth - 12, 700);
  const inner  = panelW - PANEL_PADDING * 2;
  // try to fit as many columns as possible (6â€“10)
  for (let c = 10; c >= 6; c--) {
    const cellW = (inner - GAP_PX * (c - 1)) / c;
    if (cellW >= CELL_MIN_PX) return { cols: c, cellW: Math.min(cellW, CELL_MAX_PX) };
  }
  return { cols: 6, cellW: (inner - GAP_PX * 5) / 6 };
}

function applyCellSize(cellW) {
  const r = Math.min(Math.floor(cellW * 0.26), 16);
  document.documentElement.style.setProperty('--cell', Math.floor(cellW) + 'px');
  document.documentElement.style.setProperty('--radius', r + 'px');
  // font size proportional
  document.querySelectorAll('.cell').forEach(el => {
    el.style.fontSize = Math.floor(cellW * 0.38) + 'px';
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ADJACENCY  (read-order wrap: row-end â†’ next-row-start)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DIRS8 = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

// Walk from (r,c) in direction (dr,dc) skipping dead cells.
// For horizontal dir (dr=0): right edge wraps to next row left, left edge wraps to prev row right.
// For other dirs: no column wrapping.
function walkAlive(r, c, dr, dc) {
  const maxSteps = grid.length * COLS + 4;
  let cr = r, cc = c;
  for (let i = 0; i < maxSteps; i++) {
    if (dr === 0) {
      cc += dc;
      if      (cc < 0)    { cc = COLS - 1; cr--; }
      else if (cc >= COLS){ cc = 0;         cr++; }
    } else {
      cr += dr; cc += dc;
      if (cc < 0 || cc >= COLS) return null;
    }
    if (cr < 0 || cr >= grid.length) return null;
    if (cr === r && cc === c) return null; // loop guard
    if (grid[cr][cc] !== null) return { r: cr, c: cc };
  }
  return null;
}

function isAdj(r1, c1, r2, c2) {
  for (const [dr, dc] of DIRS8) {
    const f = walkAlive(r1, c1, dr, dc);
    if (f && f.r === r2 && f.c === c2) return true;
  }
  return false;
}

function isPair(a, b) { return a === b || a + b === 10; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DISTANCE  (read-order flat index)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function flatDist(r1, c1, r2, c2) {
  const d = Math.abs((r1 * COLS + c1) - (r2 * COLS + c2));
  return d;
}

function distBonus(r1, c1, r2, c2) {
  // same cell â†’ 0; adjacent no skip â†’ 0; further = more bonus
  const d = flatDist(r1, c1, r2, c2);
  if (d <= 1) return 0;
  if (d <= 3) return 5;
  if (d <= 8) return 15;
  if (d <= 15) return 30;
  return 50;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOARD GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function rndInt() { return 1 + Math.floor(Math.random() * 9); }

// Check if grid has at least one valid pair
function hasPair(g) {
  const rows = g.length;
  for (let r1 = 0; r1 < rows; r1++) {
    for (let c1 = 0; c1 < COLS; c1++) {
      if (g[r1][c1] === null) continue;
      for (const [dr, dc] of DIRS8) {
        const f = walkAliveG(g, r1, c1, dr, dc);
        if (f && isPair(g[r1][c1], g[f.r][f.c])) return true;
      }
    }
  }
  return false;
}
function walkAliveG(g, r, c, dr, dc) {
  const maxSteps = g.length * COLS + 4;
  let cr = r, cc = c;
  for (let i = 0; i < maxSteps; i++) {
    if (dr === 0) {
      cc += dc;
      if      (cc < 0)    { cc = COLS - 1; cr--; }
      else if (cc >= COLS){ cc = 0;         cr++; }
    } else {
      cr += dr; cc += dc;
      if (cc < 0 || cc >= COLS) return null;
    }
    if (cr < 0 || cr >= g.length) return null;
    if (cr === r && cc === c) return null;
    if (g[cr][cc] !== null) return { r: cr, c: cc };
  }
  return null;
}

// Make one full row. pairRate: probability that a cell is complement of its left neighbor.
// Avoid runs of identical digits (max 2 in a row).
function makeRow(pairRate) {
  const row = [];
  for (let c = 0; c < COLS; c++) {
    let v;
    if (c > 0 && row[c-1] !== null && Math.random() < pairRate) {
      // place a cell that pairs with left neighbor
      const left = row[c-1];
      v = Math.random() < 0.5 ? left : (10 - left);
      if (v < 1 || v > 9) v = left;
      // prevent 3+ identical in a row
      if (c >= 2 && row[c-2] === v && row[c-1] === v) v = rndInt();
    } else {
      v = rndInt();
      // prevent 3 identical in a row
      if (c >= 2 && row[c-2] === v && row[c-1] === v) {
        v = (v % 9) + 1;
      }
    }
    row.push(v);
  }
  return row;
}

// Build initial grid for a stage. Validate it has pairs; retry up to 20 times.
function buildInitialGrid(cfg) {
  for (let attempt = 0; attempt < 30; attempt++) {
    const g = [];
    for (let r = 0; r < cfg.rows; r++) {
      g.push(makeRow(cfg.pairRate));
    }
    if (hasPair(g)) return g;
  }
  // fallback: inject one explicit pair
  const g = [];
  for (let r = 0; r < cfg.rows; r++) g.push(makeRow(0.5));
  g[0][0] = 5; g[0][1] = 5;
  return g;
}

// Smart add rows: inject pairable values near existing cells.
// All rows except the LAST are full (COLS cells); the last may be shorter (but still left-aligned, no gaps).
function buildAddRows(count) {
  const newRows = [];
  for (let ri = 0; ri < count; ri++) {
    const isLast = ri === count - 1;
    const fillCount = isLast
      ? (6 + Math.floor(Math.random() * (COLS - 5)))  // 6..COLS
      : COLS;
    const row = [];
    for (let c = 0; c < COLS; c++) {
      row.push(c < fillCount ? rndInt() : null);
    }
    newRows.push(row);
  }

  // Inject pairable values
  const allRows = [...grid.map(r=>[...r]), ...newRows.map(r=>[...r])];
  const totalRows = allRows.length;
  const newStart  = grid.length;
  const cfg = stageConfig(stage);

  for (let ri = newStart; ri < totalRows; ri++) {
    for (let c = 0; c < COLS; c++) {
      if (allRows[ri][c] === null) continue;
      if (Math.random() > 0.65) continue;
      // Gather alive neighbor values
      const nbVals = [];
      for (const [dr, dc] of DIRS8) {
        const f = walkAliveG(allRows, ri, c, dr, dc);
        if (f) {
          const v = allRows[f.r][f.c];
          if (typeof v === 'number' && v >= 1 && v <= 9) nbVals.push(v);
        }
      }
      if (nbVals.length === 0) continue;
      const target = nbVals[Math.floor(Math.random() * nbVals.length)];
      const comp   = 10 - target;
      // pick complement more than same, for variety
      let partner  = (Math.random() < 0.55 && comp >= 1 && comp <= 9) ? comp : target;
      if (partner < 1 || partner > 9) partner = target;
      // avoid 3 in a row
      if (c >= 2 && allRows[ri][c-1] === partner && allRows[ri][c-2] === partner) {
        partner = (partner % 9) + 1;
      }
      allRows[ri][c] = partner;
    }
  }

  return newRows.map((_, i) => allRows[newStart + i]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render(newRowIdxs = []) {
  const wrap = document.getElementById('gridWrap');
  wrap.innerHTML = '';

  const { cellW } = calcCols();
  document.documentElement.style.setProperty('--cell', Math.floor(cellW) + 'px');
  const fs = Math.floor(cellW * 0.38);
  const r2 = Math.min(Math.floor(cellW * 0.26), 16);
  document.documentElement.style.setProperty('--radius', r2 + 'px');

  for (let r = 0; r < grid.length; r++) {
    const rowEl = document.createElement('div');
    rowEl.className = 'grid-row';
    rowEl.dataset.row = r;

    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.style.width  = Math.floor(cellW) + 'px';
      cell.style.fontSize = fs + 'px';

      const v = grid[r][c];
      const vOk = (typeof v === 'number' && Number.isInteger(v) && v >= 1 && v <= 9);

      if (!vOk) {
        if (v !== null) grid[r][c] = null;
        cell.classList.add('dead');
      } else {
        cell.dataset.v = v;
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.textContent = v;
        cell.addEventListener('click', () => onCell(r, c));
        if (selected && selected.r === r && selected.c === c) cell.classList.add('sel');
      }

      if (newRowIdxs.includes(r)) {
        cell.classList.add('new-appear');
        cell.style.animationDelay = (c * 26) + 'ms';
      }
      rowEl.appendChild(cell);
    }
    wrap.appendChild(rowEl);
  }


  updateStats();
}

function getCell(r, c) {
  return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CELL CLICK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onCell(r, c) {
  if (busy) return;
  if (grid[r][c] === null) return;

  if (!selected) {
    selected = { r, c };
    render();
    setMsg(`${grid[r][c]} ã‚’ãˆã‚‰ã‚“ã ã‚ˆï¼âœ¨ ãƒšã‚¢ã‚’ã•ãŒã—ã¦ã­`, '');
    return;
  }
  if (selected.r === r && selected.c === c) {
    selected = null; render(); setMsg('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã‚ˆã€œ', '');
    return;
  }

  const v1 = grid[selected.r][selected.c];
  const v2 = grid[r][c];
  const r1 = selected.r, c1 = selected.c;
  selected = null;

  if (!isAdj(r1, c1, r, c)) {
    setMsg('ã¨ãªã‚Šã˜ã‚ƒãªã„ã‚ˆã€œğŸ˜…', 'err'); render(); return;
  }
  if (!isPair(v1, v2)) {
    setMsg(`${v1}ã¨${v2}ã¯ãƒšã‚¢ã«ãªã‚‰ãªã„ã‚ˆğŸ™…`, 'err'); render(); return;
  }

  // â”€â”€ Valid pair! â”€â”€
  busy = true;
  const cell1 = getCell(r1, c1), cell2 = getCell(r, c);
  if (cell1) { cell1.classList.remove('sel'); cell1.classList.add('popping'); }
  if (cell2) cell2.classList.add('popping');
  spawnConf(cell1); spawnConf(cell2);

  const db = distBonus(r1, c1, r, c);
  const pts = 10 + db;

  setTimeout(() => {
    grid[r1][c1] = null;
    grid[r][c]   = null;
    pairs++;
    score += pts;
    updateStats();
    render();

    if (db > 0) {
      const c2el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      const refEl = c2el || document.querySelector('.game-panel');
      if (refEl) {
        const rect = refEl.getBoundingClientRect();
        spawnFloatText(`ğŸŒŸ ï¼‹${pts}ï¼`, rect.left + rect.width / 2, rect.top, '#9933ff');
      }
      setMsg(`ãƒ­ãƒ³ã‚°ãƒœãƒ¼ãƒŠã‚¹ï¼ ï¼‹${pts}ç‚¹ğŸ’«`, 'bonus');
    } else {
      const okMsgs = ['ããˆãŸï¼ğŸ’•','ã‚„ã£ãŸï¼âœ¨','ã±ã¡ã±ã¡ğŸ‰','ã„ã„ã­ï¼ğŸŒ¸','ãƒŠã‚¤ã‚¹ï¼ğŸ’«'];
      setMsg(okMsgs[Math.floor(Math.random() * okMsgs.length)] + ` ï¼‹${pts}ç‚¹ï¼`, 'ok');
    }

    checkRowClear(() => { busy = false; checkWin(); });
  }, 400);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROW CLEAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkRowClear(cb) {
  const clearIdxs = [];
  for (let r = 0; r < grid.length; r++) {
    if (grid[r].every(v => v === null)) clearIdxs.push(r);
  }
  if (clearIdxs.length === 0) { cb(); return; }

  clearIdxs.forEach(r => {
    const el = document.querySelector(`.grid-row[data-row="${r}"]`);
    if (el) el.classList.add('row-vanish');
  });

  const bonus = clearIdxs.length * 60;
  score += bonus;
  updateStats();

  clearIdxs.forEach(r => {
    const el = document.querySelector(`.grid-row[data-row="${r}"]`);
    if (el) {
      const rect = el.getBoundingClientRect();
      spawnFloatText(`ğŸŒˆ ${clearIdxs.length}è¡Œæ¶ˆæ»…ï¼ ï¼‹${bonus}ï¼`,
        rect.left + rect.width / 2, rect.top + rect.height / 2, '#ff8800');
    }
  });

  bigConfetti(10);

  setTimeout(() => {
    for (let i = clearIdxs.length - 1; i >= 0; i--) grid.splice(clearIdxs[i], 1);
    if (grid.length === 0) grid = [];
    render();
    setMsg(`ğŸŒˆ è¡Œã¾ã‚‹ã”ã¨æ¶ˆãˆãŸï¼ ï¼‹${bonus}ç‚¹ãƒœãƒ¼ãƒŠã‚¹ï¼`, 'wow');
    cb();
  }, 560);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ADD ROWS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addRows() {
  if (busy || addsLeft <= 0) return;
  addsLeft--;
  updateStats();

  const count = 1 + Math.floor(Math.random() * 2); // 1 or 2
  const newRows = buildAddRows(count);
  const startIdx = grid.length;
  newRows.forEach(r => grid.push(r));

  render(Array.from({ length: count }, (_, i) => startIdx + i));
  const animals = ['ğŸ£','ğŸ¶','ğŸ±','ğŸ¦†'];
  setMsg(animals[Math.floor(Math.random() * animals.length)] + ` ${count}è¡Œã‚ãŸã‚‰ã—ã„ä»²é–“ï¼`, 'ok');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WIN CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function checkWin() {
  const allGone = grid.length === 0 || grid.every(row => row.every(v => v === null));
  if (!allGone) {
    // check if stuck (no pairs and no adds left)
    if (addsLeft <= 0 && !hasPair(grid)) {
      showOverlay('over');
    }
    return;
  }
  showOverlay('clear');
}

function showOverlay(mode) {
  overlayMode = mode;
  const ovEmoji = document.getElementById('ovEmoji');
  const ovTitle = document.getElementById('ovTitle');
  const ovSub   = document.getElementById('ovSub');
  const ovBtn   = document.getElementById('ovBtn');

  if (mode === 'clear') {
    ovEmoji.textContent = 'ğŸ‰ğŸŒˆğŸ‰';
    ovTitle.textContent = 'ã‚¯ãƒªã‚¢ï¼';
    ovSub.innerHTML = `ã‚¹ãƒ†ãƒ¼ã‚¸ ${stage} ã‚¯ãƒªã‚¢ï¼<br>ã‚¹ã‚³ã‚¢ï¼š${score}ç‚¹<br>ã¤ãã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸ã©ã†ãï¼`;
    ovBtn.textContent = 'ã¤ãã¸ï¼';
    // flash + confetti
    const flash = document.createElement('div');
    flash.className = 'stage-flash';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 700);
    bigConfetti(22);
  } else {
    ovEmoji.textContent = 'ğŸ˜¢ğŸ¾ğŸ˜¢';
    ovTitle.textContent = 'ã–ã‚“ã­ã‚“â€¦';
    ovSub.innerHTML = `ãƒšã‚¢ãŒãªããªã£ã¦ã—ã¾ã£ãŸï¼<br>ã‚¹ã‚³ã‚¢ï¼š${score}ç‚¹<br>ã‚‚ã†ä¸€åº¦ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`;
    ovBtn.textContent = 'ã‚‚ã†ã„ã¡ã©ï¼';
  }

  setTimeout(() => {
    document.getElementById('overlay').classList.add('show');
  }, mode === 'clear' ? 500 : 200);
}

function overlayAction() {
  document.getElementById('overlay').classList.remove('show');
  if (overlayMode === 'clear') {
    stage++;
    startStage();
  } else {
    startStage(); // retry same stage
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STAGE START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startStage() {
  const cfg = stageConfig(stage);
  const { cols } = calcCols();
  COLS = cols;

  // Rebuild grid until it's solvable with cfg.adds add operations
  let g;
  let attempts = 0;
  do {
    g = buildInitialGrid(cfg);
    attempts++;
  } while (!isSolvable(g, cfg) && attempts < 15);

  grid = g;
  selected = null;
  addsLeft = cfg.adds;
  busy = false;

  document.getElementById('stageBanner').textContent = `ã‚¹ãƒ†ãƒ¼ã‚¸ ${stage}`;
  render();
  updateStats();
  setMsg('ã™ããªæ•°å­—ã‚’ãˆã‚‰ã‚“ã§ã­ï¼', '');
}

// Quick solvability check: can we find pairs repeatedly until empty (or add helps)?
// We do a greedy check: if initial board has at least some pairs, and
// with cfg.adds extra rows we can keep going. Full solving is too expensive,
// so we just verify hasPair() on initial grid + cfg.adds full rows appended.
function isSolvable(g, cfg) {
  if (!hasPair(g)) return false;
  // simulate adding cfg.adds full rows and check there are always pairs
  const sim = g.map(r => [...r]);
  for (let a = 0; a < Math.min(cfg.adds, 3); a++) {
    // add a full random row
    const row = [];
    for (let c = 0; c < COLS; c++) row.push(rndInt());
    sim.push(row);
    if (!hasPair(sim)) return false;
  }
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStats() {
  document.getElementById('scoreVal').textContent = score;
  document.getElementById('pairsVal').textContent = pairs;
  const addEl = document.getElementById('addVal');
  addEl.textContent = addsLeft;
  addEl.className = 'pill-val' + (addsLeft <= 1 ? ' warn' : addsLeft >= 4 ? ' ok' : '');
  const addBtn = document.getElementById('addBtn');
  addBtn.disabled = addsLeft <= 0;
}

function setMsg(text, type = '') {
  const el = document.getElementById('msg');
  el.textContent = text;
  el.className = 'msg' + (type ? ' ' + type : '');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EFFECTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawnConf(el) {
  if (!el) return;
  const rect = el.getBoundingClientRect();
  const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
  for (let i = 0; i < 5; i++) {
    const d = document.createElement('div'); d.className = 'conf';
    d.textContent = CONF_CHARS[Math.floor(Math.random() * CONF_CHARS.length)];
    d.style.left = cx + 'px'; d.style.top = cy + 'px';
    const ang = Math.random() * Math.PI * 2, dist = 44 + Math.random() * 54;
    d.style.setProperty('--dx', Math.cos(ang) * dist + 'px');
    d.style.setProperty('--dy', Math.sin(ang) * dist + 'px');
    d.style.setProperty('--rot', Math.random() * 360 + 'deg');
    d.style.animationDelay = Math.random() * 0.07 + 's';
    document.body.appendChild(d);
    setTimeout(() => d.remove(), 950);
  }
}

function bigConfetti(n) {
  for (let i = 0; i < n; i++) {
    setTimeout(() => {
      const d = document.createElement('div'); d.className = 'conf'; d.style.fontSize = '24px';
      d.textContent = CONF_CHARS[Math.floor(Math.random() * CONF_CHARS.length)];
      d.style.left = Math.random() * window.innerWidth + 'px';
      d.style.top  = Math.random() * window.innerHeight + 'px';
      const ang = Math.random() * Math.PI * 2, dist = 80 + Math.random() * 110;
      d.style.setProperty('--dx', Math.cos(ang) * dist + 'px');
      d.style.setProperty('--dy', Math.sin(ang) * dist + 'px');
      d.style.setProperty('--rot', Math.random() * 720 + 'deg');
      document.body.appendChild(d);
      setTimeout(() => d.remove(), 1000);
    }, i * 55);
  }
}

function spawnFloatText(text, x, y, color) {
  const el = document.createElement('div'); el.className = 'float-text';
  el.textContent = text; el.style.left = x + 'px'; el.style.top = y + 'px';
  el.style.color = color || '#9960cc'; el.style.transform = 'translateX(-50%)';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMAL STICKERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const STICKER_DEFS = [
  { type:'chick', left:'3%',  top:'7%',  delay:0   },
  { type:'duck',  left:'88%', top:'4%',  delay:1.2 },
  { type:'dog',   left:'3%',  top:'56%', delay:0.7 },
  { type:'cat',   left:'87%', top:'60%', delay:1.8 },
  { type:'chick', left:'44%', top:'1%',  delay:2.1 },
  { type:'duck',  left:'16%', top:'83%', delay:0.4 },
  { type:'cat',   left:'70%', top:'81%', delay:1.5 },
  { type:'dog',   left:'52%', top:'86%', delay:2.6 },
];
const SZ = 68;

function initStickers() {
  const stage = document.getElementById('animalStage');
  stage.innerHTML = '';
  STICKER_DEFS.forEach(def => {
    const wrap = document.createElement('div');
    wrap.className = 'sticker';
    wrap.style.left = def.left; wrap.style.top = def.top;
    wrap.style.width = SZ + 'px'; wrap.style.height = SZ + 'px';
    wrap.innerHTML = SVGS[def.type](SZ);
    const dur = (3.4 + Math.random() * 2.4).toFixed(1);
    wrap.style.animation = `sFloat ${dur}s ease-in-out ${def.delay}s infinite`;

    wrap.addEventListener('click', () => {
      wrap.classList.remove('wiggling', 'bouncing');
      void wrap.offsetWidth;
      wrap.classList.add('bouncing');
      setTimeout(() => wrap.classList.remove('bouncing'), 580);
    });
    wrap.addEventListener('mouseenter', () => {
      if (!wrap.classList.contains('bouncing')) wrap.classList.add('wiggling');
    });
    wrap.addEventListener('mouseleave', () => wrap.classList.remove('wiggling'));
    stage.appendChild(wrap);
  });
}

document.addEventListener('mousemove', e => {
  document.querySelectorAll('.sticker').forEach(s => {
    if (s.classList.contains('bouncing')) return;
    const rect = s.getBoundingClientRect();
    const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
    const dx = e.clientX - cx, dy = e.clientY - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 100) {
      const sc = 1 + (1 - dist / 100) * 0.27;
      s.style.transform = `scale(${sc}) translate(${-dx * 0.045}px,${-dy * 0.045}px)`;
    } else {
      s.style.transform = '';
    }
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MISC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleRules() { document.getElementById('rulesPanel').classList.toggle('open'); }

function resetGame() {
  document.getElementById('overlay').classList.remove('show');
  score = 0; pairs = 0; stage = 1;
  startStage();
}

window.addEventListener('resize', () => {
  const { cols } = calcCols();
  if (cols !== COLS) { COLS = cols; render(); }
  else render(); // re-apply cell sizes
});

// â”€â”€ Boot â”€â”€
initStickers();
startStage();
</script>
</body>
</html>
